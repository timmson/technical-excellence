# Унаследованный код

> Я не хочу достичь бессмертия с помощью своей работы, я просто не буду умирать. — Вуди Аллен

Если вы работаете в большой продуктовой группе, то скорее всего за время чтения [других статей](https://less.works/ru/less/technical-excellence/index.html) вы, вероятно, думали: “Этот [ресурс](https://less.works/ru) содержит столько полезных идей, но у нас пять миллионов строк кода, написанных на нашем собственном языке программирования, которые нам нужно поддерживать. У нас это не сработает”. Тогда эта статья как раз для вас.

Существующий хорошо структурированный переиспользуемый код безусловно является ценным активом. Тем не менее, этот актив может стать плохо структурированным  унаследованным кодом без автотестов (legacy code) с неадекватной документацией и большим количеством дублирований. Унаследованный код ограничивает организационную гибкость, и как мы увидим, ведёт к серьёзному ослаблению вашей способности конкурировать. Это статья о том, как писать такой унаследованный код, и том как этого избегать.

Но перед погружением в тему нужно будет отметить, сколько рабочих мест существует благодаря унаследованному коду. Мы путешествуем по миру и часто работаем в развивающихся странах. В подобных странах люди вышли из бедности благодаря рабочим местам, созданным для поддержки устаревшего кода. Например, в Индии и Китае несколько городов существенно развились, как в размерах, так и по уровню жизни за последнее десятилетие не без помощи индустрии заказной разработки (outsourcing industry), а большая её часть относится к унаследованному коду. Мы это ценим. 

С другой стороны, что бы произошло, если бы всю эту энергию направили на творческие, инновационные продукты? Кроме того, унаследованный код разрушал компании...

![_](/img/legacy-code/browser-wars-en.png)

*Рис. 1. Доля рынка браузеров и их версии*

Браузер Netscape - один из лучших примеров, который по началу *владел* рынком. Но в 1995 году компания Microsoft осознала громадный потенциал сети Интернет и начала то, что в последствии назовут “войнами браузеров“ [[см. книгу Competing On Internet Time](https://www.amazon.com/Competing-Internet-Time-Netscape-Microsoft/dp/0684863456)]. В 2000 году она выиграла первую битву этой войны.

Этому произошло по ряду причин. Одна из них в том, что Netscape [не выпускала](http://news.cnet.com/2100-1023-248549.html) новую версию своего браузера три с половиной года. Но почему? *“Потому что браузер был переписан заново без использования прежней кодовой базы Netscape Communicator”*. В 2007 году компания AOL, (которая купила Netscape в 1999 году) официально [убила](https://www.nytimes.com/2007/12/29/technology/29browser.html) браузер Netscape.

Это статья решит все ваши проблемы с унаследованным кодом... ладно, а может и нет. Но она определённо притупит вашу боль от унаследованного кода и возможно когда-то, вы сможете полностью от него избавиться.

## Как Писать Новый Унаследованный Код

Писать унаследованный код просто - мы объясним это на примере нескольких простых шагов. За десятки лет компании создали кучу унаследованного кода. В компании Xerox мы однажды услышали: “Нам давали много уроков, но выучили мы лишь часть”. Это особенно касается унаследованного кода. Мы из раза в раз проходим этот урок, но почему-то так и не можем его выучить.  

Как давно это началось? Ещё в 1967 году, возможно, в первой [книге](https://www.amazon.com/management-computer-programming-projects/dp/B0006BRZGU) по управлению проектами разработки Чарльз Лехт (Charles Lecht) писал:

> Equally responsible for the initiation of project with predefined failure is management that insists upon having fixed commitments from programming personnel prior to the latter’s understanding what the commitments are for. Too frequently, management does not realize that in asking the staff for “the impossible”, the staff will feel the obligation to respond out of respect, fear or misguided loyalty. Saying “no” to the boss frequently requires courage, political and psychological wisdom, and business maturity that comes with much experience

> Ответственность за запуск заранее обречённого проекта в равной степени лежит как на менеджменте, который настаивает на фиксации определённых обязательств со стороны программистов, так и на самих программистах, которые не понимают то, на что соглашаются. Слишком часто менеджмент не осознает, что, прося сотрудников о “невозможном”, сотрудники будут чувствовать себя обязанными согласиться из уважения, страха или ложной лояльности. Чтобы сказать начальнику “нет”, часто требуется смелость, политическая и психологическая мудрость, а также понимание бизнеса, которые приходят с большим опытом.

Ниже указаны явные причины появления унаследованного кода:

* нереалистичные сроки и фиксированный объём работ
* низкий уровень навыков разработки

И конечно в этих причинах лежат ключи к предотвращению его возникновения...

## Как Избежать Написания Унаследованного Кода

### Избегайте нереалистичных сроков и фиксированного объёма работ

“Мы обещали этот релиз нашему основному заказчику к первому февраля, и отдел разработки *должен сдержать это обещание*” - было написано в недовольном письме директора менеджменту продуктовой группы, которую мы консультировали. Мы недоверчиво прочитали это письмо и задались вопросом о *"сдержать это обещание"*. Решили не обращать пока на него особого внимания и вернуться к *обычной* работе - обучению одного из разработчиков рефакторингу унаследованного компонента, который был сляпан на скорую во время последнего релиза, чтобы успеть в срок.

Многие компании застряли в порочном круге *навязанных обещаний* и *невыполнимых обязательств*. Сегодня, в эру высоких скоростей, клиенты ‘принуждают’ их обещать слишком многое. “Если вы не можете поставить к концу года, мы купим у вашего конкурента, который даст такое обещание”. Отдел продаж или руководство могли бы отреагировать, проявив прозрачность и стремясь к взаимовыгодным долгосрочным отношениям (сотрудничество с заказчиком), но вместо этого они озадачены, прописана ли неустойка в договоре за несоблюдение приемлемых сроков (согласование условий контракта), и отвечают: “Да, без проблем, мы это сделаем!”. После этого тот же цикл начинается уже внутри организации. Руководство приказывает главе разработки “сделать это” или “сделать так, чтобы это случилось”, потому что “это обещано клиентам”. Обещание путешествует по организационной структуре к разработчикам, которые не могут передать его дальше.

Как разработчик обычно реагирует? Чарльз Лехт уже нас предупреждал более 50 лет назад: Разработчик будет *“обязан согласиться из уважения, страха или ложной лояльности”* и неохотно, но соглашается на эти сроки. Разработчик открывает свой *секретный ящик с инструментами* и делает всё возможное, чтобы успеть к ближайшему сроку, используя *инструменты*, такие, как хардкод, копипаст-программирование, игнорирование тестов, сверхурочные и другие, разрушающие качество и срезающие углы практики [см. книгу The Enterprise and Scrum](https://www.amazon.com/Enterprise-Scrum-Developer-Best-Practices/dp/0735623376). Никто не обращает внимание на использование этих ‘инструментов’, поэтому что сроки соблюдены. Менеджмент награждает разработчиков за их тяжёлый труд и восхваляет их за “отличную командную работу” и “боевой дух”.

Эти разрушающие качество и срезающие углы практики приводят к ужасному унаследованному коду, который замедляет разработку, а организация проигрывает конкурентам. Предсказуемый сценарий. Им необходимо вернуть себе рынок и, следовательно, дать новые обещания, снова запуская этот порочный круг. **Технический долг** - это унаследованный код, замедляющий разработку. **Долг обучения** - нехватка новых навыков у разработчиков усугубляет это отставание. Разработчики настолько заняты, выполняя неосуществимые обязательства, что у них нет времени развивать свои навыки.

![_](/img/legacy-code/causal-loop-legacy-en.png)

*Рис. 2. Динамика нереалистичных сроков*
  
Боб Мартин в книге *[Чистый Код](http://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882)* утверждает, что настоящие мастера своего дела не давали бы таких невыполнимых обещаний, а проблема унаследованного кода могла быть решена обучением разработчиков, чтобы повысить их *профессионализм*.

Мартин частично прав. Но этот взгляд игнорирует тот факт, что разработчик является частью бóльшей системы, которая усиливает это поведение. Нужно,  не только развивать мастерство разработчиков, но и улучшать *систему*, в которой они работают, в целом.
                                      
Однажды в Европе мы посетили директора большой продуктовой группы (которая разрабатывала встраиваемые системы) и его команду менеджеров. Директор объяснил, что группа успешно выпустила последний релиз, и поставил под сомнение необходимость внедрения масштабируемого Скрама. В этот момент один из его подчинённых сказал: “Ну, на самом деле ближе к дате релиза мы сильно отставали, поэтому мы много работали сверхурочно, выдернули более сотни человек из другого продукта нам в помощь. Поэтому мы и успели. Сейчас мы серьёзно отстаём от графика, потому что в последнем релизе было создано так много плохого кода, что мы тратим бóльшую часть времени на исправление дефектов, о которых сообщают нам наши клиенты, и вынуждены работать с беспорядком в кодовой базе”.  

Обратите внимание на взаимосвязь между этими событиями и отсутствием бережливого мышления. Например, в этих случаях прослеживается *утрата связи с реальностью* (waste of wishful thinking). Один из трёх источников потерь в бережливом мышлении - *перегрузка* (overburden) - часто можно увидеть, как героический рывок ближе к концу релиза приводит к ещё большим потерям в будущем. Также отсутствует культура *остановись и исправь* (stop and fix) -  а наблюдается противоположная ей “нет времени точить, нужно пилить” (carry on and don’t fix).

Если вы скажите своим клиентам: “Мы не понимаем, что происходит, и понятия не имеем, когда это будет сделано”, то это будет коммерческим самоубийством. Мы часто слышим от руководителей фразу: *“Либо мы берём на себя нереалистичные обязательства, либо у нас не будет работы”*. Это убеждение является ложной дихотомией.

Есть другой способ, когда клиент и заказчик вместе понимают суть продуктовой разработки: она не предсказуема на 95%. Вы можете принять эту реальность, если будете демонстрировать прозрачность по отношению к своим клиентам во время разработки. Например, ...

* предоставляя информацию о текущем статусе разработки вашим ключевым клиентам каждую итерацию; например, с помощью Диаграммы Сгорания Релиза (Release Burndown Chart) и обновлённого Бэклога Продукта
* давая возможность ключевым клиентам предоставлять обратную связь по приоритетам и изменению целей по мере того, как они видят, как идут дела, а затем корректируя план соответствующим образом
* предоставляя оценки с указанием их точности (вероятности) или несколько оценок (по разным сценариям) [см. книгу Вальсируя с Медведями](https://www.amazon.com/Waltzing-Bears-Managing-Software-Projects/dp/0932633609)
* используя другие техники, которые поощряет частое взаимодействие с клиентами, основанные на реальности и прозрачности

Благодаря изменениям в том, как продуктовые компании взаимодействуют со своими клиентами, снижается давление, приводящее к созданию унаследованного кода.
                                                                                                                                                    
Часто менеджмент прибегает к "быстрому решению" (quick-fix) в ответ на давление рынка - ‘заказать’ разработке “ещё ресурсов”, так как это ‘дешёво’. Мы работали с продуктовой группой, которую *принудили* нанять сотни людей в течение года. Исключение? Нет, вот ещё пример: лидер продуктовой группы, с которой мы работали, недавно был ‘назначен‘ руководить новым продуктом. В этом продукте работало 900 человек в 12 разных офисах и 20 активных филиалах. Этот продукт отставал от конкурентов, и предыдущее руководство пыталось спасти его, добавляя больше людей - теперь они отставали ещё больше.

Вот ещё урок, который *даётся* снова и снова. Возможно, первым крупномасштабным проектом в мире была [SAGE](https://en.wikipedia.org/wiki/Semi-Automatic_Ground_Environment) система, которая разрабатывалась в 1950-х. Команда проекта торопилась, поэтому...

> В течение года примерно **1000 человек** были вовлечены в разработку системы SAGE. Люди из самых разных слоёв общества были наняты и обучены. Проводники трамвая, сотрудники похоронного бюро (изучавших математику не менее года), школьные учителя, мойщики окон и другие в спешном порядке были собраны, обучены программированию в течение нескольких недель и распределены по разным отделам очень большой организации... Изначально ожидаемый **объем работ был значительно уменьшен**. Первый релиз состоялся **с опозданием на год** и **значительно превысил бюджет**<sup>[1](#footnote-1)</sup>.

Вместо фокуса на выращивании великих разработчиков или найма небольшого количества крутых людей они сконцентрировались на найме максимального количества “*голов*” (англ. heads, head count) что, в свою очередь, приводит к поспешной и неадекватной образовательной программе для новых сотрудников. Это быстрое решение приводит к группам с низким средним уровнем навыков разработки, группам с низкой способностью быть хорошими разработчиками и, в конечном итоге, ко все большему и большему количеству плохого унаследованного кода.

### Низкие Навыки Разработчиков

Организационная динамика обещаний и обязательств полностью не описывает историю об унаследованном коде. Боб Мартин прав - индустрии определённо точно нужны хорошие инженеры.

Нам кажется, что средний уровень навыков разработчиков в больших продуктовых группах довольно низкий. Разработчики часто не знакомы с хорошими базовыми техниками - простыми практиками, таки как сокрытие и инкапсуляция, или принципы хорошего дизайна. При разработке встраиваемых систем мы иногда слышим восклицания “Это техники для ООП, а мы пишем на языке Си”, но их авторы не понимают, что некоторые из этих концептов были разработаны для не-объектно-ориентированных языков <sup>[2](#footnote-2)</sup>. Мы наблюдали следующий тренд

> Чем больше продуктовая группа, тем меньший объём знаний ‘современных’ практик разработки

Но эти практики являются основными для бесконечно [повторяемого процесса разработки](https://www.amazon.com/Sustainable-Software-Development-Agile-Perspective/dp/0321286081). К счастью, навыки разработки зависят не только от чистого таланта; они могут быть изучены и улучшены с помощью

* школ
* поддержки в организации
* самообучения

Руководство продуктовой группы может полагать, что понимает, как работают эти образовательные форумы, но это может быть не так...

**Школы** — В университетах не преподают базовые навыки разработчикам. Это шокирующий разрыв между академическим образованием и промышленной разработкой. Многие преподаватели никогда не работали в промышленной разработки и не могли наблюдать долгосрочную динамику навыков разработки и унаследованного кода. Им также не хватает практики Пойди и Посмотри. Некоторые университеты недавно добавили гибкие практики разработки в их учебную программу по информатике. Это хорошо. Однако требуется глубокий опыт, чтобы действительно понять гибкие практики, такие как разработка через тестирование (TDD), а преподаватели редко имеют такой опыт.

As such, do not assume that university graduates have much skill in software development—especially in agile development.

**Поддержка в организации** — Многие компании слабо поддерживают обучение разработчиков. Мы часто слышим: “Каждый выпускник университета может писать код”, тем самым подразумевая, что обучение базовым навыкам разработки не требуется. Наш тренерский опыт говорит об обратном. Многим разработчикам в больших продуктовых группах не хватает фундаментальных навыков, таких как хороший дизайн программного обеспечения, эффективная работа с редакторами, эффективное использование своего языка программирования или автоматизация задач путём написания сценариев. Организации терпят неудачи в обучении в этих областях, потому что многие бизнес-лидеры разумно, но ошибочно полагают, что люди приобрели эти навыки в университете, не зная, что учебная программа по информатике не учит навыкам разработки программного обеспечения, и что большинство университетских профессоров не знают и не могут преподавать современные практика разработки<sup>[3](#footnote-3)</sup>.

В отличие от них организации, практикующие практики бережливого мышления, инвестируют в обучение своих сотрудников. Одно исследование показывает, что японские компании тратят в восемь раз больше усилий на обучение новых сотрудников, чем их коллеги в США, и в два раза больше, чем их европейские коллеги [[см. книгу The Machine That Changed the World](https://www.amazon.com/Machine-That-Changed-World-Revolutionizing/dp/0743299795)].

Организации также не осознают необходимость постоянного улучшения. Им необходимо не только обучать базовым навыкам, но и создавать среду, в которой сотрудники постоянно сталкиваются с проблемами и учатся. Как? Менеджеры, выступающие в роли учителей, коллеги, обучающие друг друга (например, с помощью парного программирования), а также внутренние или внешние выделенные коучи - все это поддерживает культуру обучения и постоянного совершенствования.

**Самообучение** — Многие разработчики не следят за поддержанием своих навыков в актуальном состоянии. Гуру качества Филип Кросби (Philip Crosby) [видел](https://www.amazon.com/Quality-Free-Certain-Becomes-Business/dp/0070145121) недостаток знаний, вызванный нехваткой обучения, как главную причину плохого качества.

> Люди подсознательно тормозят собственный интеллектуальный рост. Они начинают полагаться на клише и привычки. Когда они достигают возраста личного комфорта в мире, они перестают учиться, и их ум остаётся бездействующим до конца своих дней. Они могут развиваться в организационном плане, они могут быть амбициозными и нетерпеливыми, и они могут даже работать день и ночь. Но они больше ничего не узнают.

В 1999 году Дейв Томас (Dave Thomas) и Энди Хант (Andy Hunt) опубликовали превосходную книгу [*The Pragmatic Programmer*](http://www.amazon.com/Pragmatic-Programmer-Journeyman-Master/dp/020161622X)], обобщающей отношение и поведение современного профессионального разработчика. Мы призываем людей читать её и брать на себя ответственность за то, чтобы быть в курсе последних событий.

### Избегайте тривилизации разработки

“*Я архитектор, написанием кода должны заниматься люди более низкого уровня*”. Мы слышим подобные заявления от архитекторов из башни из слоновой кости, которые считают, что программирование ниже их уровня. Организация, в которой работает этот архитектор, создала культуру тривилизации (упрощение, признание обыденным, англ. trivializing) программирования. Такая культура принижает значение кода, обесценивает написание чистого кода и обесценивает знания о программировании. В такой культуре люди хотят подняться в социальной и организационной иерархии - а это означает отход от программирования. Программирование является всего лишь ранним этапом карьеры, который им предстоит пройти. Такая культура порождает унаследованный код.

Организации тривилизируют разработку с помощью:

* аутсорсинг (англ. outsourcing) разработки
* карьерная лестница
* разница в зарплате

**Аутсорсинг разработки** — Особенно в больших продуктовых группах мы сталкиваемся с руководством, которое не считает написание кода своим “основным бизнесом”, и поэтому передали его на аутсорсинг. Они составляют спецификации, архитектурную и проектную документацию, а затем отправляют их дешёвым разработчикам в оффшор, чтобы “выполнить внедрение и тестирование.” Рецепт катастрофы. Исходный код - это место реальной ценности - гемба. Подробнее смотрите:

* [“Выращивание”, а не “строительство” - Создавайте культуру живого, растущего дизайна системы”](architecture-design.ru.md#выращивание-а-не-строительство---создавайте-культуру-живого-растущего-дизайна-системы)
* [“Архитекторы и системные инженеры являются постоянными членами фиче-команд”](architecture-design.ru.md#архитекторы-и-системные-инженеры-являются-постоянными-членами-фиче-команд)
* [“Избегайте архитектурных астронавтов (PowerPoint-архитекторов)”](architecture-design.ru.md#избегайте-архитектурных-астронавтов--powerpoint-архитекторов)
* [“Не позволяйте архитекторам просто “передавать” требования конечным разработчикам”](architecture-design.ru.md#не-позволяйте-архитекторам-просто-передавать-требования-конечным-разработчикам)
* [“Избегайте создания ‘дизайна’ и последующей отправки его в оффшор для реализации”](architecture-design.ru.md#избегайте-создания-дизайна-и-последующей-отправки-его-в-оффшор-для-реализации)

**Карьерная лестница** — Крупные организации хотят обеспечить будущим своих сотрудников; предопределённые управленческие или технические карьерные пути - типичное решение. Люди, идущие по пути менеджмента, уходят от технической работы и становятся “профессиональными менеджерами”. Те, кто идёт по техническому пути, тратят своё время на написание “архитектурных документов”. Какой бы карьерный путь вы ни выбрали, он не будет содержать никакого программирования.

**Разница в зарплате** — Из всех профессий, связанных с разработкой программного обеспечения, зарплата программистов в среднем одна из самых низких (см. книгу [Applied Software Measurement](https://www.amazon.com/Applied-Software-Measurement-Analysis-Productivity/dp/0071502440)). Естественно, но, к сожалению, эта разница в заработной плате не способствует тому, чтобы стать лучшим разработчиком, а вместо этого способствует прекращению работы в качестве разработчика. Есть ли альтернатива? Пит МакБрин (Pete McBreen) [продвигает](https://www.amazon.com/Software-Craftsmanship-Imperative-Pete-McBreen/dp/0201733862) модель мастерства в области программного обеспечения, в которой зарплата напрямую связана с навыками. Навыки разработчиков измеряются портфолио разработчика и отзывами коллег.

## Повышайте осведомлённость негативного влияния унаследованного кода

Больше *унаследованного* кода - это не просто помеха, это *якорь*. Трудно быстро поставить ценность и быстро адаптироваться, когда ваши огромные 15 миллионов строк кода представляют собой дымящуюся кучу... ну, вы знаете чего.

Некоторые разработчики и многие нетехнические специалисты в продуктовой разработки не осознают негативное влияние унаследованного кода - с точки зрения затрат на обслуживание этого технического долга и с точки зрения возможностей, утраченных из-за снижения скорости и способности вносить изменения.

Мы призываем технических руководителей активно информировать своих бизнес-людей и техническое сообщество по этому вопросу и исследовать стоимость устаревшего кода.

## Хорошо, у нас есть унаследованный код, что дальше

Вы, вероятно, понимаете причины появления унаследованного кода, но он у вас уже есть. Как от него избавиться? В своей книге [*Working Effectively with Legacy Code*](http://www.amazon.com/Working-Effectively-Legacy-Michael-Feathers/dp/0131177052) Майкл Физерс (Michael Feathers) рассказывает о конкретных методах разработки для постепенного улучшения вашего кода. В этой статье мы не будем повторяться; мы рекомендуем книгу Физерса. Но мы рассмотрим некоторые общие стратегии работы с унаследованным кодом.

### Избегайте переписывания унаследованного кода

Столкнувшись с унаследованным кодом, разработчики часто предлагают его переписать, изменить дизайн или перестроить архитектуру - отказаться от унаследованного кода и написать его снова. В следующий раз будет лучше... Сопротивляйтесь этому искушению. Почему?

В продуктовой группе с 30-летней кодовой базой разработчик спросил нас, можем ли мы помочь в рефакторинге (улучшение, переделывание, англ. refactoring) функции из 5000 строк. Мы думали, что он преувеличивает. Но когда мы объединили и измерили функцию, мы обнаружили, что она немного больше 5000 строк кода. Как могла быть создана такая функция? Просыпается разработчик и думает: “Боже, какой сегодня чудесный день! Напишем функцию из 5000 строк?”. Вероятно, что нет. Когда разработчик пишет новый код, он обычно *пишет* его с приличным качеством. Но со временем качество ухудшается. И функция *становиться* из 5000 строк. Почему так происходит? Клиент запрашивает новое требование, и оно ломает логику текущего решения из-за плохих навыков разработки или нереалистичных сроков. Качество кода снижается, а усилия, необходимые для внесения изменений, возрастают (см. Иллюстрацию 3).

![_](/img/legacy-code/code-quality1-en.png)

*Рис. 3. Качество кода падает со временем*

Через какое-то время вносить изменения в код становится слишком болезненно и требуется слишком много усилий; разработчики начинают просить переделать существующее решение. Сначала Владелец продукта отказывается - переписывание означает высокую затраты без добавления новой ценности для продукта. Но по мере того, как скорость разработки падает, разработчики жалуются все больше, и в конечном итоге владелец продукта ‘соглашается’ на переделывание. Во время него способность реагировать на изменения - новые требования - равна нулю. Но после окончания переработки код получается качественным, а значит, и новая разработка идёт быстро (см. Иллюстрацию 4).

![_](/img/legacy-code/code-quality2-en.png)

*Рис. 4. Переделывание улучшает качество*

Что происходит после? Давление поспешить с новыми требованиями приводит к загрязнению только что очищенного кода, что снова приводит к ухудшению качества и увеличению усилий по разработке (см. Иллюстрацию 5). Через некоторое время разработчики требуют ещё раз всё переделать. В некоторых крупных продуктовых группах мы видели, как компоненты переписывались трижды.

![_](/img/legacy-code/code-quality3-en.png)

*Рис. 5. Качество кода вновь после переписывания*

---
**Ключевой момент: Проблема не в наличии унаследованного коде, а в его создании.**

---

Концентрация должна быть на предотвращении создания нового унаследованного кода, а не на нём самом. Фокус должен быть на *выращивании здорового кода* вместо предоставления ему возможности деградировать со временем. Как? Улучшайте качество кода каждый раз, когда меняете его. *“Если бы мы все оставляли после себя наш код немного чище, чем когда мы за него взялись, тл код просто не мог гнить”* - [утверждает](http://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882) Боб Мартин (см. Иллюстрацию 6).

![_](/img/legacy-code/code-quality4-en.png)

*Рис. 6: Выращивание здорового кода*

## Улучшайте код по соседству

Выращивание здорового кода - ключевая стратегия устранения устаревшего кода. Вы можете следовать ей, улучшая также “соседей“ (небольшие участки вокруг вашего кода, который вы меняете) и постепенно исправляя [“разбитые окна“](http://www.amazon.com/Pragmatic-Programmer-Journeyman-Master/dp/020161622X). Каждый раз, когда вы вносите изменения, оглядывайтесь вокруг своей точки изменения - на её соседей - код, который может быть улучшен - разбитые окна - добавьте пару тестов, проведите рефакторинг (см. Иллюстрацию 7). Когда начинаете применять эту практику, каждое изменение происходит немного медленнее. Но со временем код улучшается, а скорость разработки увеличивается из-за более здорового кода.

![_](/img/legacy-code/clean-neighbourhood-en.png)

*Рис. 7: Улучшайте код по соседству*

Унаследованный код означает наличие технического долга - а из долгов стоит выбираться. Стратегия переделывания пытается погасить долг сразу. С другой стороны, улучшение кода по соседству распределяет выплаты. Она фокусирует усилия на тех частях, которые меняются больше всего - на самых важных. Унаследованный код, который не меняется и не улучшается - и это нормально.

### Пишите высокоуровневые и модульные тесты

Нас часто спрашивают, начинать ли с модульных тестов или с высокоуровневых тестов. Ещё одна ложная дихотомия. Они все важны! Часто проще добавить высокоуровневые тесты к унаследованной кодовой базе, и они помогают гарантировать, что существующие функциональные возможности работают. Но модульные тесты работают быстро. Быстро выполняемые модульные тесты помогают при постепенном рефакторинге унаследованного кода. Поэтому напишите модульные тесты *и* высокоуровневые тесты при улучшении по соседству.

### Переписывайте мёртвый унаследованный код

Иногда невозможно постепенно провести оздоровление кодовой базы. Например, предположим, что часть низкоуровневого кода написана на PL/M (устаревший процедурный язык, прим. переводчика), и никто не хочет изучать PL/M. Или часть вашего кода написана на доморощенном языке, компилятор которого работает только на VAX/VMS (проприетарная серверная операционная система, прим. переводчика). Когда постепенное изменение невозможно<sup>[4](#footnote-4)</sup> - унаследованный код уже мёртв - тогда необходимо ‘ампутировать‘ эту часть кода вместо того, чтобы позволить ей убить ваш продукт.

При замене мёртвого кода:

* покройте его тестами
* не добавляйте функциональности в старый код
* не добавляйте функциональности в заменённый код

## Заключение

В мире существуют миллиарды строк устаревшего кода, и их количество увеличивается с каждым днём. Это создало огромные проблемы (например, Проблема 2000 года), и оно будет создавать монументальные в будущем. Но унаследованный код не исчезнет, если не будут устранены первопричины:

* нереалистичные сроки сдачи фиксированного объёма работ
* низкий уровень навыков разработки

Их можно решить, обучая людей устранять причины унаследованного кода и улучшая их уровень образованности. Однако промышленность десятилетиями не осознавала эти причины. Вряд ли это изменится в ближайшие несколько лет.

Как работать с существующим унаследованным кодом? Лучше постепенно улучшать код, чем полностью заменять его. Это требует инвестиций в навыки разработки и применения современных практик, таких как TDD. Единственный способ вырастить лучший код - это вырастить отличных людей. Это тема бережливого мышления.

> Создание вещей - это в первую очередь создание людей (англ. Making things is about making people) [Summary Notes from Art Smalley Interview with Mr. Isao Kato, 2006](http://artoflean.com/wp-content/uploads/2019/01/Mr_Kato_Interview_on_TWI_and_TPS.pdf).

## Рекомендуем к Прочтению

В то время, когда мы пишем эту книгу, было написано на удивление мало о такой огромной и дорогостоящей проблеме, как унаследованный код. Вот некоторые полезные ссылки, связанные с постепенным улучшением вашего кода:

* [*Эффективная работа с унаследованным кодом*](http://www.amazon.com/Working-Effectively-Legacy-Michael-Feathers/dp/0131177052) Майкла Физерса. Конкретные советы о том, как постепенно улучшать унаследованную систему на уровне кода.
* [*Рефакторинг. Улучшение существующего кода*](https://www.amazon.com/Refactoring-Improving-Existing-Addison-Wesley-Signature-ebook/dp/B07LCM8RG2) Мартина Фаулера. Классическая работа про улучшение существующего кода.
* [*Refactoring Workbook*](https://www.amazon.com/Refactoring-Workbook-William-C-Wake/dp/0321109295) Билла Вейка. Конкретное руководство по совершенствованию рефакторинга кода.
* [*Рефакторинг с использованием шаблонов*](https://www.amazon.com/Refactoring-Patterns-Joshua-Kerievsky/dp/0321213351) Джошуа Кериевски. В этой книге Джошуа объясняет, как постепенно реорганизовать код по стандартным надёжным шаблонам проектирования.
* [*Refactoring in Large Software Projects*](https://www.amazon.com/Refactoring-Large-Software-Projects-Restructurings/dp/0470858923/) Стефана Рука и Мартина Липперта. Для больших систем может потребоваться большой рефакторинг. В этой книге объясняется, как сделать это как можно более мелкими шагами, чтобы ваши системы оставались стабильными.

Следующий материал охватывает организационную динамику, связанную с унаследованным кодом:

* [*The Enterprise and Scrum (Developer Best Practices)*](https://www.amazon.com/Ken-Schwaber/dp/0735623376/) Кена Швабера. Глава 9 - одно из немногих описаний, объясняющих взаимосвязь между обещаниями клиентов и созданием унаследованного кода.
* [*Sustainable Software Development: An Agile Perspective*](https://www.amazon.com/Sustainable-Software-Development-Agile-Perspective/dp/0321286081/) Кэвина Тейта. Эта книга не охватывает многих новых техник, но даёт отличный обзор методов устойчивого создания программного обеспечения.

Мастер разработки программного обеспечения предотвращает создание унаследованного кода и, следовательно, разрабатывает программное обеспечение с устойчивой скоростью. Некоторые материалы о том, как стать мастером разработки:

* [*The Pragmatic Programmer*](http://www.amazon.com/Pragmatic-Programmer-Journeyman-Master/dp/020161622X) Энди Ханта и Дейва. Классическая книга по мастерству современного программного обеспечения.
* [*Software Craftsmanship: The New Imperative*](https://www.amazon.com/Software-Craftsmanship-Imperative-Pete-McBreen/dp/0201733862) Пита МакБрина погружается в профессиональный подход и сравнивает его с традиционной перспективой разработки программного обеспечения.
* [*Чистый код: создание, анализ и рефакторинг. Библиотека программиста*](http://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882) Боба Мартина. Подзаголовок говорит сам за себя. Чистый код является приквелом к...
* [*Agile Development, Principles, Patterns and Practices*](http://www.amazon.com/Software-Development-Principles-Patterns-Practices/dp/0135974445) Боба Мартина. Также известная как Agile PPP, она связывает хороший код, современные практики и вечные принципы дизайна, чтобы объяснить, что значит быть мастером.

## Сноски

1. <a name="footnote-1"></a> статья Дж. Шварфца “Построение ПО: Проблемы и Практики” (J. Schwartz, Constructing of Software: Problems and Practices), позже опубликованная в [книге](http://www.amazon.com/Practical-Strategies-Developing-Software-Systems/dp/0201029774)), жирный шрифт добавлен.
2. <a name="footnote-2"></a> Например, статья Д. Парнаса (D. Parnas) [“On the Criteria To Be Used in Decomposing Systems into Modules”](https://www.win.tue.nl/~wstomv/edu/2ip30/references/criteria_for_modularization.pdf).
3. <a name="footnote-3"></a> “Используйте редактор кода, к которому вы привыкли” - это, пожалуй, самый эффективный курс повышения производительности, который вы можете преподавать во многих компаниях.
4. <a name="footnote-4"></a> Редко бывает невозможно сделать постепенное изменение. Поэтому бросайте вызов каждый раз, когда кто-то говорит, что постепенное изменение невозможно. Статья Д. Парнаса (D. Parnas) [“Software Aging, Proceedings of the 16th International Conference on Software Engineering”](https://dl.acm.org/doi/10.5555/257734.257788), также доступная в книге [Software Fundamentals: Collected Papers by David L.Parnas](https://www.amazon.com/Software-Fundamentals-Collected-Papers-Parnas/dp/0201703696).
