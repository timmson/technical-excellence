# Унаследованный код

> Я не хочу достичь бессмертия с помощью своей работы, я просто не буду умирать. — Вуди Аллен

Если вы работаете в большой продуктовой группе, то скорее всего за время чтения [других статей](https://less.works/ru/less/technical-excellence/index.html) вы, вероятно, думали: “Этот [ресурс](https://less.works/ru) содержит столько полезных идей, но у нас пять миллионов строк кода, написанных на нашем собственном языке программирования, которые нам нужно поддерживать. У нас это не сработает”. Тогда эта статья как раз для вас.

Существующий хорошо структурированный переиспользуемый код безусловно является ценным активом. Тем не менее, этот актив может стать плохо структурированным  унаследованным кодом без автотестов (legacy code) с неадекватной документацией и большим количеством дублирований. Унаследованный код ограничивает организационную гибкость, и как мы увидим, ведёт к серьёзному ослаблению вашей способности конкурировать. Это статья о том, как писать такой унаследованный код, и том как этого избегать.

Но перед погружением в тему будет нужно отметить, сколько работы существуют благодаря унаследованному коду. Мы путешествуем по миру и часто работаем в развивающихся странах. Там люди вышли из бедности благодаря рабочим местам, созданным для поддержки устаревшего кода. В таких странах, как Индия и Китай, несколько городов выросли в размерах и уровне жизни за последнее десятилетие не без помощи индустрии заказной разработки (outsourcing industry), и большая её часть относится к унаследованному коду. Это стоит отметить тоже. С другой стороны, что бы произошло, если бы всю эту энергию направили на творческие, инновационные продукты? Кроме того, унаследованный код разрушал компании...

![_](/img/legacy-code/browser-wars-en.png)

*Иллюстрация 1. Доля рынка и релизы браузеров*

Браузер Netscape - один из лучших примеров, который по началу *владел* рынком браузеров. Но в 1995 года компания Microsoft осознала громадный потенциал сети Интернет и начала то, что в последствии назовут “войнами браузеров“ [[см. книгу Competing On Internet Time](https://www.amazon.com/Competing-Internet-Time-Netscape-Microsoft/dp/0684863456)]. В 2000 году она выиграла первую битву браузеров.

Для этого было много причин. Одна из них в том, что Netscape [не выпускала](http://news.cnet.com/2100-1023-248549.html) новой версии своего браузера три с половиной года. Но почему? *“Потому что браузер был переписан заново, без использования кодовой базы, что формировала основу Netscape’s Communicator browser”*. В 2007 компания AOL, (которая купила Netscape в 1999 году) официально [убила](http://blog.netscape.com/2007/12/28/end-of-support-for-netscape-web-browsers) браузер Netscape.

Это статья решит все ваши проблемы с унаследованным кодом... хорошо, а может и нет. Но она сделает вашу проблему унаследованного кода немного менее болезненной и возможно, в один день, решённой.

## Как Писать Новый Унаследованный Код

Писать унаследованный код просто - мы объясним это за несколько простых шагов. Компании создают кучи унаследованного кода за одно десятилетие. В компании Xerox мы однажды услышали изречение: “Мы преподавали много уроков, не выучили мы несколько”. Это отчасти правда для унаследованного кода. Как предотвратить *преподавание* такого урока унаследованного кода снова и снова, который так и не бы выучен?  

Как долго он преподаётся? Ещё в 1967 году, возможно, в первой [книге](https://www.amazon.com/management-computer-programming-projects/dp/B0006BRZGU) о проектах по разработке ПО автор учил нас:

> В равной степени ответственным за начало проекта с заранее понятным провалом является руководство, которое настаивает на наличии фиксированных обязательств со стороны программистов до того, как последний поймёт, для чего эти обязательства. Слишком часто руководство не осознает, что, прося сотрудников о “невозможном”, сотрудники будут чувствовать себя обязанными ответить из уважения, страха или ошибочной лояльности. Чтобы сказать начальнику “нет”, часто требуется смелость, политическая и психологическая мудрость, а также деловая зрелость, которая приходит с большим опытом.

Ниже указаны чёткие причины унаследованного кода:

* нереалистичные сроки сдачи фиксированного объёма работ
* низкий уровень навыков разработки

И конечно в этих причинах лежат ключи к предотвращению унаследованного кода...

## Как Избежать Написания Унаследованного Кода

### Избегайте нереалистичных сроков сдачи фиксированного объёма работ

“Мы обещали передать этот релиз нашим ключевым клиентам, и ждём первое февраля, как *единственно приемлемые обязательства* от отдела разработки” - было написано в злом письме директора менеджменту продуктовой группы, которую мы консультировали. Мы недоверчиво прочитали это письмо и задались вопросом о *единственно приемлемых обязательствах*. Мы решили не обращать пока на него внимания и вернуться к *обычной* работе - обучению разработчика рефакторингу унаследованного компонента, который был сломан вместе с последним релизом, чтобы успеть к этому срок.

Много компаний застревают в порочном круге *навязанных обещаний* и *неосуществимых обязательств*. Сегодня в эру высоких скоростей клиенты ‘принуждают’ их обещать слишком многое. “Если вы не можете поставить к концу года, мы купим у вашего конкурента, кто даёт такое обещание”. Отдел продаж или руководство могли бы отреагировать, проявив прозрачность и стремясь к взаимовыгодным долгосрочным отношениям (сотрудничество с клиентами), но вместо этого они проверяют, является ли штраф в договоре за несоблюдение сроков приемлемым (переговоры по контракту) и отвечают: “Да, без проблем, мы это сделаем!”. После этого такой же цикл начинается внутри организации. Руководство приказывает главе разработки “сделать это” или “сделать так, чтобы это случилось”, потому что “это обещано клиентам”. Обещание путешествует по организационной структуре к разработчикам, которые не могут передать его дальше.

Как разработчики должны реагировать? [Чарльз Лехт](https://www.amazon.com/management-computer-programming-projects/dp/B0006BRZGU) (Charles Lecht) уже нас предупреждал более 40 лет назад: Разработчик будет *“чувствовать себя обязанными ответить из уважения, страха или ошибочной лояльности”* и неохотно соглашаются на предложенные сроки. Разработчик открывает свой *секретный ящик с инструментами* и делает всё возможное, чтобы успеть к ближайшему сроку, используя *инструменты*, такие, как зашитые в код данные (hardcoding), программирование методом скопировать-вставить-поправить (copy-paste-modify programming), отсутствие тестов, переработки и другие, разрушающие качество и срезающие углы практики [см. книгу The Enterprise and Scrum](https://www.amazon.com/Enterprise-Scrum-Developer-Best-Practices/dp/0735623376). Никто не замечает этих ‘инструментов’, и поэтому сроки соблюдены. Менеджмент награждает разработчиков за их тяжёлый труд и восхваляет их за “отличную командную работу” и “дух борьбы”.

Эти разрушающие качество и срезающие углы практики отражаются в плохом унаследованном коде, который замедляет разработку, и организация проигрывает конкуренцию. Предсказуемый сценарий. Им необходимо вернуть себе рынок и, следовательно, дать новые обещания, снова запуская порочный круг. **Технический долг** - унаследованный код, замедляющий разработку. **Долг обучения** - недостаток развития новых навыков у разработчиков усугубляет это замедление. Разработчики настолько заняты, давай неосуществимые обязательства, что у них нет времени поддерживать свои навыки в актуальном состоянии.

![_](/img/legacy-code/causal-loop-legacy-en.png)

*Иллюстрация 2. Динамика нереалистичных сроков*

Боб Мартин в книге *[Чистый Код](http://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882)* утверждает, что мастера не давали бы таких невыполнимых обещаний, и проблема унаследованного кода могла быть решена обучением разработчиков, чтобы повысить их *профессионализм*.

Мартин частично прав. Но это представление игнорирует тот факт, что разработчик является частью большой системы, которая изменяет его поведение. Нужно, чтобы не только разработчики поменялись, но и *система* в целом, в которой они работают.

Однажды в Европе мы посетили директора большой продуктовой группы (которая разрабатывала встраиваемые системы) и его команду менеджеров. Директор объяснил, что группа успешно достигла цель в последнем релизе, и поставил под сомнение мотивацию для внедрения масштабируемого Скрама. В этот момент один из его менеджеров заговорил и сказал: “Что ж, на самом деле ближе к концу последнего релиза мы сильно отстали, поэтому мы много работали сверхурочно, вытащили более сотни человек из другого продукта и заставили их помочь. Вот почему мы выполнили поставку к сроку. Сейчас мы серьёзно отстаём от графика текущего релиза, потому что в последнем релизе было создано так много плохого кода, что мы тратим большую часть времени на исправление дефектов, о которых сообщают нам наши клиенты, и вынуждены работать с беспорядком в кодовой базе”.  

Обратите внимание на взаимосвязь между этими ситуациями и отсутствием бережливого мышления. Например, *потеря от выдачи желаемого за действительное* присутствует в этих случаях. Один из трёх источников потерь в бережливом мышлении - *перегрузка* (overburden) - легко увидеть, как героический толчок ближе к концу релиза приводит к ещё большим потерям в будущем. И тут также нет культуры *остановись и исправь* (stop and fix) - с точностью противоположная “продолжай и не исправляй”.

Сказать вашим клиентам “Мы не понимаем сути и понятия не имеем, когда это будет сделано будет” коммерческим суицидом. Но это беспокойство, которое мы часто слышим от руководителей, является ложной дихотомией - либо *брать на себя нереалистичные обязательства, либо вообще не брать на себя никаких обязательств*.

Есть альтернатива, когда клиент и заказчик вместе принимают реальность продуктовой разработки: Она не предсказуема на 95%. Вы можете принять эту реальность, если будете демонстрировать прозрачность по отношению к своим клиентам во время разработки. Например, ...

* отчитываясь о вашем статусе разработки вашим ключевым клиентам каждую итерацию; например, с помощью Диаграммы Сгорания Релиза (Release Burndown chart) и обновлённого Бэклога Продукта
* давая возможность ключевым клиентам оставлять обратную связь по приоритетам и изменении целей по мере того, как они видят, как идут дела, а затем корректируют план соответствующим образом
* предоставляя оценки с распределением вероятности или несколько оценок [см. книгу Вальсируя с Медведями](https://www.amazon.com/Waltzing-Bears-Managing-Software-Projects/dp/0932633609)
* используя другие техники, которые продвигают частое взаимодействие с клиентами, основанные на реальности и прозрачности

Благодаря изменениям, как продуктовые компании относятся к своим клиентам, уменьшается давление, создающее унаследованный код.

Обычный быстрый ответ менеджмента на давление рынка в ‘приказе’ разработке “добавить больше ресурсов”, пока они ‘дешёвые’. Мы работали с продуктовой группой, которую *принудили* набрать сотни людей за период в один-два года. Исключение? Нет, вот ещё пример: руководитель продуктовой группы, с которой мы работали, недавно был ‘повышен‘ до нового продукта. В новом продукте было 900 человек, 12 разных офисов и 20 активных филиалов. Этот продукт отставал от конкурентов, и предыдущее руководство пыталось спасти его, добавляя больше людей - теперь оно отставало ещё больше.

Вот другой урок, который *преподаётся* снова и снова. Возможно, первым крупномасштабным проектом в мире была [SAGE](https://en.wikipedia.org/wiki/Semi-Automatic_Ground_Environment) система, которая разрабатывалась в 1950-х. Проект торопился, поэтому...

> В течение года примерно **1000 человек** было вовлечено в разработку SAGE системы. Были набраны и обучены люди из самых разных слоёв общества. Проводники трамвая, сотрудники похоронного бюро (по крайней мере, с одним годом обучения математике), школьные учителя, чистильщики занавесок и другие были в спешном порядке собраны, обучены программированию в течение определённого количества недель и распределены по частям в очень сложной организации... Первоначально ожидаемые **мощности системы были значительно сокращены**. Система была впервые поставлена **с опозданием в год** и **значительно дороже**, чем ожидалось<sup>[1](#footnote-1)</sup>.

Вместо фокуса на выращивании великих разработчиков или найма небольшого количества крутых людей они сконцентрировались на найме максимального количества “*голов*” (англ. heads, head count) что, в свою очередь, приводит к поспешной и неадекватной образовательной программе для новых сотрудников. Это быстрое решение приводит к группам с низким средним уровнем навыков разработки, группам с низкой способностью быть хорошими разработчиками и, в конечном итоге, ко все большему и большему количеству плохого унаследованного кода.

### Низкие Навыки Разработчиков

Организационная динамика обещаний и обязательств полностью не описывает историю об унаследованном коде. Боб Мартин прав - индустрии определённо точно нужны хорошие инженеры.

Нам кажется, что средний уровень навыков разработчиков в больших продуктовых группах довольно низкий. Разработчики часто не знакомы с хорошими базовыми техниками - простыми практиками, таки как сокрытие и инкапсуляция, или принципы хорошего дизайна. При разработке встраиваемых систем мы иногда слышим восклицания “Это техники для ООП, а мы пишем на языке Си”, но их авторы не понимают, что некоторые из этих концептов были разработаны для не-объектно-ориентированных языков <sup>[2](#footnote-2)</sup>. Мы наблюдали следующий тренд

> Чем больше продуктовая группа, тем меньший объём знаний ‘современных’ практик разработки

Но эти практики являются основными для бесконечно [повторяемого процесса разработки](https://www.amazon.com/Sustainable-Software-Development-Agile-Perspective/dp/0321286081). К счастью, навыки разработки зависят не только от чистого таланта; они могут быть изучены и улучшены с помощью

* школ
* поддержки в организации
* самообучения

Руководство продуктовой группы может полагать, что понимает, как работают эти образовательные форумы, но это может быть не так...

**Школы** — В университетах не преподают базовые навыки разработчикам. Это шокирующий разрыв между академическим образованием и промышленной разработкой. Многие преподаватели никогда не работали в промышленной разработки и не могли наблюдать долгосрочную динамику навыков разработки и унаследованного кода. Им также не хватает практики Пойди и Посмотри. Некоторые университеты недавно добавили гибкие практики разработки в их учебную программу по информатике. Это хорошо. Однако требуется глубокий опыт, чтобы действительно понять гибкие практики, такие как разработка через тестирование (TDD), а преподаватели редко имеют такой опыт.

As such, do not assume that university graduates have much skill in software development—especially in agile development.

**Поддержка в организации** — Многие компании слабо поддерживают обучение разработчиков. Мы часто слышим: “Каждый выпускник университета может писать код”, тем самым подразумевая, что обучение базовым навыкам разработки не требуется. Наш тренерский опыт говорит об обратном. Многим разработчикам в больших продуктовых группах не хватает фундаментальных навыков, таких как хороший дизайн программного обеспечения, эффективная работа с редакторами, эффективное использование своего языка программирования или автоматизация задач путём написания сценариев. Организации терпят неудачи в обучении в этих областях, потому что многие бизнес-лидеры разумно, но ошибочно полагают, что люди приобрели эти навыки в университете, не зная, что учебная программа по информатике не учит навыкам разработки программного обеспечения, и что большинство университетских профессоров не знают и не могут преподавать современные практика разработки<sup>[3](#footnote-3)</sup>.

В отличие от них организации, практикующие практики бережливого мышления, инвестируют в обучение своих сотрудников. Одно исследование показывает, что японские компании тратят в восемь раз больше усилий на обучение новых сотрудников, чем их коллеги в США, и в два раза больше, чем их европейские коллеги [[см. книгу The Machine That Changed the World](https://www.amazon.com/Machine-That-Changed-World-Revolutionizing/dp/0743299795)].

Организации также не осознают необходимость постоянного улучшения. Им необходимо не только обучать базовым навыкам, но и создавать среду, в которой сотрудники постоянно сталкиваются с проблемами и учатся. Как? Менеджеры, выступающие в роли учителей, коллеги, обучающие друг друга (например, с помощью парного программирования), а также внутренние или внешние выделенные коучи - все это поддерживает культуру обучения и постоянного совершенствования.

**Самообучение** — Многие разработчики не следят за поддержанием своих навыков в актуальном состоянии. Гуру качества Филип Кросби (Philip Crosby) [видел](https://www.amazon.com/Quality-Free-Certain-Becomes-Business/dp/0070145121) недостаток знаний, вызванный нехваткой обучения, как главную причину плохого качества.

> Люди подсознательно тормозят собственный интеллектуальный рост. Они начинают полагаться на клише и привычки. Когда они достигают возраста личного комфорта в мире, они перестают учиться, и их ум остаётся бездействующим до конца своих дней. Они могут развиваться в организационном плане, они могут быть амбициозными и нетерпеливыми, и они могут даже работать день и ночь. Но они больше ничего не узнают.

В 1999 году Дейв Томас (Dave Thomas) и Энди Хант (Andy Hunt) опубликовали превосходную книгу [*The Pragmatic Programmer*](http://www.amazon.com/Pragmatic-Programmer-Journeyman-Master/dp/020161622X)], обобщающей отношение и поведение современного профессионального разработчика. Мы призываем людей читать её и брать на себя ответственность за то, чтобы быть в курсе последних событий.

### Избегайте тривилизации разработки

“*Я архитектор, написанием кода должны заниматься люди более низкого уровня*”. Мы слышим подобные заявления от архитекторов из башни из слоновой кости, которые считают, что программирование ниже их уровня. Организация, в которой работает этот архитектор, создала культуру тривилизации (упрощение, признание обыденным, англ. trivializing) программирования. Такая культура принижает значение кода, обесценивает написание чистого кода и обесценивает знания о программировании. В такой культуре люди хотят подняться в социальной и организационной иерархии - а это означает отход от программирования. Программирование является всего лишь ранним этапом карьеры, который им предстоит пройти. Такая культура порождает унаследованный код.

Организации тривилизируют разработку с помощью:

* аутсорсинг (англ. outsourcing) разработки
* карьерная лестница
* разница в зарплате

**Аутсорсинг разработки** — Особенно в больших продуктовых группах мы сталкиваемся с руководством, которое не считает написание кода своим “основным бизнесом”, и поэтому передали его на аутсорсинг. Они составляют спецификации, архитектурную и проектную документацию, а затем отправляют их дешёвым разработчикам в оффшор, чтобы “выполнить внедрение и тестирование.” Рецепт катастрофы. Исходный код - это место реальной ценности - гемба. Подробнее смотрите:

* [“Выращивание”, а не “строительство” - Создавайте культуру живого, растущего дизайна системы”](architecture-design.ru.md#выращивание-а-не-строительство---создавайте-культуру-живого-растущего-дизайна-системы)
* [“Архитекторы и системные инженеры являются постоянными членами фиче-команд”](architecture-design.ru.md#архитекторы-и-системные-инженеры-являются-постоянными-членами-фиче-команд)
* [“Избегайте архитектурных астронавтов (PowerPoint-архитекторов)”](architecture-design.ru.md#избегайте-архитектурных-астронавтов--powerpoint-архитекторов)
* [“Не позволяйте архитекторам просто “передавать” требования конечным разработчикам”](architecture-design.ru.md#не-позволяйте-архитекторам-просто-передавать-требования-конечным-разработчикам)
* [“Избегайте создания ‘дизайна’ и последующей отправки его в оффшор для реализации”](architecture-design.ru.md#избегайте-создания-дизайна-и-последующей-отправки-его-в-оффшор-для-реализации)

**Карьерная лестница** — Крупные организации хотят обеспечить будущим своих сотрудников; предопределённые управленческие или технические карьерные пути - типичное решение. Люди, идущие по пути менеджмента, уходят от технической работы и становятся “профессиональными менеджерами”. Те, кто идёт по техническому пути, тратят своё время на написание “архитектурных документов”. Какой бы карьерный путь вы ни выбрали, он не будет содержать никакого программирования.

**Разница в зарплате** — Из всех профессий, связанных с разработкой программного обеспечения, зарплата программистов в среднем одна из самых низких (см. книгу [Applied Software Measurement](https://www.amazon.com/Applied-Software-Measurement-Analysis-Productivity/dp/0071502440)). Естественно, но, к сожалению, эта разница в заработной плате не способствует тому, чтобы стать лучшим разработчиком, а вместо этого способствует прекращению работы в качестве разработчика. Есть ли альтернатива? Пит МакБрин (Pete McBreen) [продвигает](https://www.amazon.com/Software-Craftsmanship-Imperative-Pete-McBreen/dp/0201733862) модель мастерства в области программного обеспечения, в которой зарплата напрямую связана с навыками. Навыки разработчиков измеряются портфолио разработчика и отзывами коллег.

## Повышайте осведомлённость негативного влияния унаследованного кода

Больше *унаследованного* кода - это не просто помеха, это *якорь*. Трудно быстро поставить ценность и быстро адаптироваться, когда ваши огромные 15 миллионов строк кода представляют собой дымящуюся кучу... ну, вы знаете чего.

Некоторые разработчики и многие нетехнические специалисты в продуктовой разработки не осознают негативное влияние унаследованного кода - с точки зрения затрат на обслуживание этого технического долга и с точки зрения возможностей, утраченных из-за снижения скорости и способности вносить изменения.

Мы призываем технических руководителей активно информировать своих бизнес-людей и техническое сообщество по этому вопросу и исследовать стоимость устаревшего кода.

## Хорошо, у нас есть унаследованный код, что дальше

Вы, вероятно, понимаете причины появления унаследованного кода, но он у вас уже есть. Как от него избавиться? В своей книге [*Working Effectively with Legacy Code*](http://www.amazon.com/Working-Effectively-Legacy-Michael-Feathers/dp/0131177052) Майкл Физерс (Michael Feathers) рассказывает о конкретных методах разработки для постепенного улучшения вашего кода. В этой статье мы не будем повторяться; мы рекомендуем книгу Физерса. Но мы рассмотрим некоторые общие стратегии работы с унаследованным кодом.

### Избегайте переписывания унаследованного кода

Столкнувшись с унаследованным кодом, разработчики часто предлагают его переписать, изменить дизайн или перестроить архитектуру - отказаться от унаследованного кода и написать его снова. В следующий раз будет лучше... Сопротивляйтесь этому искушению. Почему?

В продуктовой группе с 30-летней кодовой базой разработчик спросил нас, можем ли мы помочь в рефакторинге (улучшение, переделывание, англ. refactoring) функции из 5000 строк. Мы думали, что он преувеличивает. Но когда мы объединили и измерили функцию, мы обнаружили, что она немного больше 5000 строк кода. Как могла быть создана такая функция? Просыпается разработчик и думает: “Боже, какой сегодня чудесный день! Напишем функцию из 5000 строк?”. Вероятно, что нет. Когда разработчик пишет новый код, он обычно *пишет* его с приличным качеством. Но со временем качество ухудшается. И функция *становиться* из 5000 строк. Почему так происходит? Клиент запрашивает новое требование, и оно ломает логику текущего решения из-за плохих навыков разработки или нереалистичных сроков. Качество кода снижается, а усилия, необходимые для внесения изменений, возрастают (см. Иллюстрацию 3).

![_](/img/legacy-code/code-quality1-en.png)

*Иллюстрация 3. Качество кода падает со временем*

Через какое-то время вносить изменения в код становится слишком болезненно и требуется слишком много усилий; разработчики начинают просить переделать существующее решение. Сначала Владелец продукта отказывается - переписывание означает высокую затраты без добавления новой ценности для продукта. Но по мере того, как скорость разработки падает, разработчики жалуются все больше, и в конечном итоге владелец продукта ‘соглашается’ на переделывание. Во время него способность реагировать на изменения - новые требования - равна нулю. Но после окончания переработки код получается качественным, а значит, и новая разработка идёт быстро (см. Иллюстрацию 4).

![_](/img/legacy-code/code-quality2-en.png)

*Иллюстрация 4. Переделывание улучшает качество*

Что происходит после? Давление поспешить с новыми требованиями приводит к загрязнению только что очищенного кода, что снова приводит к ухудшению качества и увеличению усилий по разработке (см. Иллюстрацию 5). Через некоторое время разработчики требуют ещё раз всё переделать. В некоторых крупных продуктовых группах мы видели, как компоненты переписывались трижды.

![_](/img/legacy-code/code-quality3-en.png)

*Иллюстрация 5. Качество кода вновь после переписывания*

---
**Ключевой момент: Проблема не в наличии унаследованного коде, а в его создании.**

---

Концентрация должна быть на предотвращении создания нового унаследованного кода, а не на нём самом. Фокус должен быть на *выращивании здорового кода* вместо предоставления ему возможности деградировать со временем. Как? Улучшайте качество кода каждый раз, когда меняете его. *“Если бы мы все оставляли после себя наш код немного чище, чем когда мы за него взялись, тл код просто не мог гнить”* - [утверждает](http://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882) Боб Мартин (см. Иллюстрацию 6).

![_](/img/legacy-code/code-quality4-en.png)

*Иллюстрация 6: Выращивание здорового кода*

## Улучшайте код по соседству

Выращивание здорового кода - ключевая стратегия устранения устаревшего кода. Вы можете следовать ей, улучшая также “соседей“ (небольшие участки вокруг вашего кода, который вы меняете) и постепенно исправляя [“разбитые окна“](http://www.amazon.com/Pragmatic-Programmer-Journeyman-Master/dp/020161622X). Каждый раз, когда вы вносите изменения, оглядывайтесь вокруг своей точки изменения - на её соседей - код, который может быть улучшен - разбитые окна - добавьте пару тестов, проведите рефакторинг (см. Иллюстрацию 7). Когда начинаете применять эту практику, каждое изменение происходит немного медленнее. Но со временем код улучшается, а скорость разработки увеличивается из-за более здорового кода.

![_](/img/legacy-code/clean-neighbourhood-en.png)

*Иллюстрация 7: Улучшайте код по соседству*

Унаследованный код означает наличие технического долга - а из долгов стоит выбираться. Стратегия переделывания пытается погасить долг сразу. С другой стороны, улучшение кода по соседству распределяет выплаты. Она фокусирует усилия на тех частях, которые меняются больше всего - на самых важных. Унаследованный код, который не меняется и не улучшается - и это нормально.

### Пишите высокоуровневые и модульные тесты

Нас часто спрашивают, начинать ли с модульных тестов или с высокоуровневых тестов. Ещё одна ложная дихотомия. Они все важны! Часто проще добавить высокоуровневые тесты к унаследованной кодовой базе, и они помогают гарантировать, что существующие функциональные возможности работают. Но модульные тесты работают быстро. Быстро выполняемые модульные тесты помогают при постепенном рефакторинге унаследованного кода. Поэтому напишите модульные тесты *и* высокоуровневые тесты при улучшении по соседству.

### Переписывайте мёртвый унаследованный код

Иногда невозможно постепенно провести оздоровление кодовой базы. Например, предположим, что часть низкоуровневого кода написана на PL/M (устаревший процедурный язык, прим. переводчика), и никто не хочет изучать PL/M. Или часть вашего кода написана на доморощенном языке, компилятор которого работает только на VAX/VMS (проприетарная серверная операционная система, прим. переводчика). Когда постепенное изменение невозможно<sup>[4](#footnote-4)</sup> - унаследованный код уже мёртв - тогда необходимо ‘ампутировать‘ эту часть кода вместо того, чтобы позволить ей убить ваш продукт.

При замене мёртвого кода:

* покройте его тестами
* не добавляйте функциональности в старый код
* не добавляйте функциональности в заменённый код

## Заключение

В мире существуют миллиарды строк устаревшего кода, и их количество увеличивается с каждым днём. Это создало огромные проблемы (например, Проблема 2000 года), и оно будет создавать монументальные в будущем. Но унаследованный код не исчезнет, если не будут устранены первопричины:

* нереалистичные сроки сдачи фиксированного объёма работ
* низкий уровень навыков разработки

Их можно решить, обучая людей устранять причины унаследованного кода и улучшая их уровень образованности. Однако промышленность десятилетиями не осознавала эти причины. Вряд ли это изменится в ближайшие несколько лет.

Как работать с существующим унаследованным кодом? Лучше постепенно улучшать код, чем полностью заменять его. Это требует инвестиций в навыки разработки и применения современных практик, таких как TDD. Единственный способ вырастить лучший код - это вырастить отличных людей. Это тема бережливого мышления.

> Создание вещей - это в первую очередь создание людей (англ. Making things is about making people) [Summary Notes from Art Smalley Interview with Mr. Isao Kato, 2006](http://artoflean.com/wp-content/uploads/2019/01/Mr_Kato_Interview_on_TWI_and_TPS.pdf).

## Рекомендуем к Прочтению

В то время, когда мы пишем эту книгу, было написано на удивление мало о такой огромной и дорогостоящей проблеме, как унаследованный код. Вот некоторые полезные ссылки, связанные с постепенным улучшением вашего кода:

* [*Эффективная работа с унаследованным кодом*](http://www.amazon.com/Working-Effectively-Legacy-Michael-Feathers/dp/0131177052) Майкла Физерса. Конкретные советы о том, как постепенно улучшать унаследованную систему на уровне кода.
* [*Рефакторинг. Улучшение существующего кода*](https://www.amazon.com/Refactoring-Improving-Existing-Addison-Wesley-Signature-ebook/dp/B07LCM8RG2) Мартина Фаулера. Классическая работа про улучшение существующего кода.
* [*Refactoring Workbook*](https://www.amazon.com/Refactoring-Workbook-William-C-Wake/dp/0321109295) Билла Вейка. Конкретное руководство по совершенствованию рефакторинга кода.
* [*Рефакторинг с использованием шаблонов*](https://www.amazon.com/Refactoring-Patterns-Joshua-Kerievsky/dp/0321213351) Джошуа Кериевски. В этой книге Джошуа объясняет, как постепенно реорганизовать код по стандартным надёжным шаблонам проектирования.
* [*Refactoring in Large Software Projects*](https://www.amazon.com/Refactoring-Large-Software-Projects-Restructurings/dp/0470858923/) Стефана Рука и Мартина Липперта. Для больших систем может потребоваться большой рефакторинг. В этой книге объясняется, как сделать это как можно более мелкими шагами, чтобы ваши системы оставались стабильными.

Следующий материал охватывает организационную динамику, связанную с унаследованным кодом:

* [*The Enterprise and Scrum (Developer Best Practices)*](https://www.amazon.com/Ken-Schwaber/dp/0735623376/) Кена Швабера. Глава 9 - одно из немногих описаний, объясняющих взаимосвязь между обещаниями клиентов и созданием унаследованного кода.
* [*Sustainable Software Development: An Agile Perspective*](https://www.amazon.com/Sustainable-Software-Development-Agile-Perspective/dp/0321286081/) Кэвина Тейта. Эта книга не охватывает многих новых техник, но даёт отличный обзор методов устойчивого создания программного обеспечения.

Мастер разработки программного обеспечения предотвращает создание унаследованного кода и, следовательно, разрабатывает программное обеспечение с устойчивой скоростью. Некоторые материалы о том, как стать мастером разработки:

* [*The Pragmatic Programmer*](http://www.amazon.com/Pragmatic-Programmer-Journeyman-Master/dp/020161622X) Энди Ханта и Дейва. Классическая книга по мастерству современного программного обеспечения.
* [*Software Craftsmanship: The New Imperative*](https://www.amazon.com/Software-Craftsmanship-Imperative-Pete-McBreen/dp/0201733862) Пита МакБрина погружается в профессиональный подход и сравнивает его с традиционной перспективой разработки программного обеспечения.
* [*Чистый код: создание, анализ и рефакторинг. Библиотека программиста*](http://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882) Боба Мартина. Подзаголовок говорит сам за себя. Чистый код является приквелом к...
* [*Agile Development, Principles, Patterns and Practices*](http://www.amazon.com/Software-Development-Principles-Patterns-Practices/dp/0135974445) Боба Мартина. Также известная как Agile PPP, она связывает хороший код, современные практики и вечные принципы дизайна, чтобы объяснить, что значит быть мастером.

## Сноски

1. <a name="footnote-1"></a> статья Дж. Шварфца “Построение ПО: Проблемы и Практики” (J. Schwartz, Constructing of Software: Problems and Practices), позже опубликованная в [книге](http://www.amazon.com/Practical-Strategies-Developing-Software-Systems/dp/0201029774)), жирный шрифт добавлен.
2. <a name="footnote-2"></a> Например, статья Д. Парнаса (D. Parnas) [“On the Criteria To Be Used in Decomposing Systems into Modules”](https://www.win.tue.nl/~wstomv/edu/2ip30/references/criteria_for_modularization.pdf).
3. <a name="footnote-3"></a> “Используйте редактор кода, к которому вы привыкли” - это, пожалуй, самый эффективный курс повышения производительности, который вы можете преподавать во многих компаниях.
4. <a name="footnote-4"></a> Редко бывает невозможно сделать постепенное изменение. Поэтому бросайте вызов каждый раз, когда кто-то говорит, что постепенное изменение невозможно. Статья Д. Парнаса (D. Parnas) [“Software Aging, Proceedings of the 16th International Conference on Software Engineering”](https://dl.acm.org/doi/10.5555/257734.257788), также доступная в книге [Software Fundamentals: Collected Papers by David L.Parnas](https://www.amazon.com/Software-Fundamentals-Collected-Papers-Parnas/dp/0201703696).
