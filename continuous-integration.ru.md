# Непрерывная интеграция / Continuous Integration

| Источник | Статус |
| - | - |
| [Ссылка](https://less.works/ru/less/technical-excellence/continuous-integration.html) | *В работе* |

## Содержание

- [Введение](#Введение)
- [Практики непрерывной интеграции](#Практики-непрерывной-интеграции)
- [Заключение](#Заключение)
- [Рекомендуем к прочтению](#Рекомендуем-к-прочтению)
- [Сноски](#Сноски)

## Введение

> Использование COBOL калечит разум; исходя из этого, обучение этому языку должно быть признано уголовно наказуемым преступлением.
> --Эдсгер Дейкстра

Непрерывная интеграция (CI) является основой для масштабирования бережливой и гибкого разработки ПО:

> Мы пришли к выводу, что нет никаких причин, по которым процессы непрерывной интеграции и автоматической сборки не будут масштабироваться на команды любого размера. На самом деле ... [они] становятся более важными, чем когда-либо. [Magennis07](http://blog.aspiring-technology.com/file.axd?file=Continuous+Integration+at+Enterprise+Scale.pdf)

С помощью CI разработчики постепенно развивают стабильную систему, работая небольшими порциями и короткими циклами. Это позволяет командам работать над общим кодом, улучшает его качество и повышает прозрачность разработки.

Существует неправильное представление о CI; это кажется простой концепцией, но на практике это не так. Попробуем избавиться от одного из частых заблуждений: *Непрерывная Интеграция это не автоматизация сборки или запуск тестов*.

[Классическая статья о **CI**](https://martinfowler.com/articles/continuousIntegration.html) постулирует:

> Непрерывная интеграция ― это практика разработки программного обеспечения, в которой участники команды часто выполняют интеграцию своих изменений. Как правило, каждый участник выполняет интеграцию как минимум раз в день, и в итоге достигается такой режим работы, при котором интеграция выполняется несколько раз в день. Каждая интеграция проверяется путём автоматической сборки (включающей тестирование), что позволяет находить ошибки интеграции как можно скорее. 

## Практики непрерывной интеграции

Непрерывная интеграция...

- это практика разработки...
- сохраняет работоспособность системы
- приветствует небольшие изменения
- способствует "выращиванию" системы
- проводится по крайней мере ежедневно
- сохраняет основную ветку в рабочем состоянии
- поддерживается CI-системами
- c большим количеством автотестов

### Практика разработки

Слишком часто дискуссии о CI касаются инструментов автоматизации. Хотя CI по сути является практикой разработки. Оуэн Роджерс, один из первых создателей CruiseControl.NET<sup>1</sup>, пишет:

> Непрерывная интеграция - это практика, и речь идёт о том, что люди делают, а не о том, какие инструменты они используют. Когда проект начинает масштабироваться, легко попасть в ловушку, думая, что команда практикует непрерывную интеграцию только потому, что все инструменты настроены и работают. Если разработчики не взяли себе за правило регулярной интегрировать свои изменения или поддерживать интеграционную среду в рабочем состоянии, то они не практикуют непрерывную интеграцию. И точка. [Rogers04](https://link.springer.com/chapter/10.1007%2F978-3-540-24853-8_8)

Разбиение изменений в коде на небольшие порции, их интеграция, не менее 1 раза в день, и не ломающаяся сборка - все это выполняется каждым разработчиком. Для этого нужен навык работы с небольшими приращениями и постоянной синхронизацией своей собственной копии системы (или её части) с общей версии.

Внедрение CI требует изменения *поведения людей*. Мы работали в несколькими крупных продуктах с отлично автоматизированной сборкой, но разработчики не часто интегрировали свой код. Хуже того, культура "не ломайте сборку" активно насаждалась, и в том числе через позор людей, сломавших сборку. Как вы думаете, к какому результату это привело? Разработчики стали откладывать интеграции из-за страха что-то сломать. Несмотря на их превосходную *всегда зелёную* (всегда проходящую) автоматизированную сборку, они делают вещи, прямо противоположные практике CI.

Помогает разработка через тестирование (TDD) с постоянным рефакторингом. Когда разработчик тестирует свой код модульным тестом, он гарантирует, что его локальная копия всегда работает. Все тесты должны проходить все время. Теоретически он может интегрировать общий код каждый цикл TDD (около десяти минут<sup>2</sup>), но на практике достаточно это делать после пары циклов. CI для больших продуктов сложен именно потому, что это практика разработки. Если бы речь шла только об инструментах автоматизации, вы могли бы просто начать проект по внедрению CI или нанять другую компанию для этой работы. Но как практика разработки, CI требует изменения в повседневных привычках всех разработчиков. Для многих людей это сложно, требует времени и постоянных тренировок. При наличии правильных привычках, разработчики будут...

## Держать систему в рабочем состоянии

По аналогии с [концептом бережливого производства - **Дзидока(jidoka)**](https://less.works/ru/less/principles/lean-thinking.html), CI подразумевает всегда держать систему в рабочем состоянии. Если тест не пройден, при локальном прогоне или в CI-инструменте, разработчик исправляет его немедленно и, следовательно, всегда сохраняет систему в рабочем состоянии.

Традиционный последовательный процесс разработки постоянно имеет дезинтегрированную незавершённую работу (work in progress, WIP). Никто не знает, работают ли эти части системы вместе и есть ли дефекты. WIP затрудняет прогнозирование того, когда система может быть готова. CI повышает прозрачность, устраняя этот WIP, всегда сохраняя интегрированным все части между собой и обеспечивая контроль и предсказуемость процесса.

___
**Примечание: CI и итеративно-инкрементальное разработка в Scrum имеют одинаковую стратегию. Тем не менее, CI является более конкретной практикой, чем итерация в Scrum. Оба уменьшают изменчивость, неопределённость и риск, работая c небольшими порциями итеративно.**
___

Такая система, находящаяся постоянно в рабочем состоянии, развивается небольшими шагами, создаётся с помощью ...

### "Резиновая курица"

Разработчик Джеймс Шор, автор книги "Искусство гибкой разработки" (The Art of Agile Development) [[SW07](https://www.amazon.com/Art-Agile-Development-Pragmatic-Software/dp/0596527675)], подчёркивает, что CI это практика разработки. В своей отличной статье "Непрерывная интеграция за 1 доллар в день" [[Shore06](https://www.jamesshore.com/Blog/Continuous-Integration-on-a-Dollar-a-Day.html)], он объясняет, как сделать CI из старого компьютера, резиновой курицы, настольного звонка и автоматизированной сборки. Старый компьютер используется в качестве сервера интеграции. резиновая курица это *маркер интеграции* - только тот, у кого она, может интегрировать код. Настольный звонок объявляет об успешной интеграции. Но самый важный шаг в его описание CI состоит в том, чтобы собрать разработчиков в одной комнате и дать им возможность договориться друг с другом: "Отныне наш код в системе контроля версий всегда будет успешно собираться и проходить все тесты". Резиновая курица не подходит для крупных продуктов. Тем не менее, это история хороший способ запомнить, что CI - это практика разработки. 

![continuous-integration-chicken.png](img/continuous-integration-chicken.png)

## Небольшие изменения

Однажды мы работали с продуктовой группой в Финляндии, которая разрабатывала шлюз. Им нужно было внести изменения в их стек протоколов. Они настаивали на том, что его нельзя разделить на небольшие изменения. Они внесли много правок и потратили три месяца, пытаясь заставить систему снова работать. После этого мучительного опыта они согласились никогда не вносить такие большие изменения "за один раз". Большие изменения в работающей системе в значительной степени дестабилизируют и разрушат её. Чем больше изменение, тем больше времени требуется, чтобы стабилизировать её состояние. Избегайте больших изменений. Вместо этого разбивайте каждое изменение на мелкие части - небольшие партии, одна из концепций бережливого производства. Каждое изменение легко интегрируется в систему. С небольшими изменениями вы будете ...

## "Выращивать" систему

*Выращивание*, а не строительство - важная смена парадигмы мышления. Фредерик Брукс в своей знаменитой статье [No Silver Bullet](http://www.cs.nott.ac.uk/~cah/G51ISS/Documents/NoSilverBullet.html) отражает свой опыт:

> Метафора "строительства" исчерпала свою полезность... Если, как я полагаю, концептуальные структуры, которые мы строим сегодня, слишком сложны, чтобы их можно было точно определить заранее, и слишком сложны, чтобы их можно было безошибочно построить, тогда мы должны использовать радикально иной подход... Секрет в том, что это **выращено, а не построено**... Харлан Миллс предложил, чтобы любая программная система росла путём инкрементальной разработки... Ничто за последнее десятилетие так радикально не изменило мою собственную практику или её эффективность... Моральные эффекты поражают. Энтузиазм резко возрастает, когда есть работающая система, пусть и самая простая... На каждом этапе процесса всегда есть работающая система. Я нахожу, что команды могут "вырастить" гораздо более сложные структуры за четыре месяца, чем они могут "построить". *Строительство* системы подразумевает сборку отдельных компонентов и, когда они закончены, их совместную сборку. *Выращивание* системы подразумевает её развитие и превращение в более крупную систему (см. "Выращивание против строительства").

![continuous-integration-grow-versus-bolt.png](https://less.works/img/technical-excellence/xcontinuous-integration-grow-versus-bolt.png.pagespeed.ic.edbUunw5nz.webp)

___
Выращивание против строительства
___

Возможно ли это в больших системах с унаследованными кодом? Нас часто спрашивают об этом. Почти в каждом случае ответ - да. Если ваши разработчики или архитекторы не могут этого сделать или утверждают, что это невозможно, воспринимайте это как признак отсутствия у них соответствующих навыков.

Разработчик постоянно интегрирует свою работу, работая над задачей. Он не ждёт завершения задачи или всей задачи, чтобы затем "прикрутить" её к системе. Скорее, всякий раз, когда небольшой объем работы может быть интегрирован без разрушения системы, он интегрирует её...

## По крайней мере ежедневно
"Непрерывно" это как часто? Как можно чаще! Это может быть ограничено лишь:

- способностью делить большие изменения на части
- скоростью интеграции
- скоростью цикла обратной связи

**Способность делить большие изменения на части** - разбивать большие изменения на более мелкие, сохраняя при этом работоспособность старой функционала - это навык, который необходимо освоить. Чем лучше разработчики умеют декомпозировать, тем чаще они могут интегрироваться. TDD в коротких десятиминутных циклах, является отличной техникой для этого.

**Скорость интеграции** - чем больше времени требуется для интеграции изменений в репозиторий кода, тем реже разработчики будут это делать. Изменения объединяются ради эффективности. На усилия по интеграции влияют накладные расходы (транзакционные издержки), такие как согласования и проверки, необходимые для того, чтобы разработчикам было разрешено интегрироваться. Уменьшите эти накладные расходы или найдите новые креативные способы сделать что-то по-другому. Например, мы работали с командой продуктовой группы, состоящей из 40 человек, где в сообщении при вливании изменений в основную ветку должно было быть упомянут человек, просмотревший этот код. Как вы думаете, какой результат? Разработчики собирали все изменения в одну пачку, чтобы сделать обзор кода более "эффективными" и, следовательно, откладывали интеграцию до последнего. Что является локальной оптимизацией. Какое решение? Вместо этого обзор изменений может выполняться на уже интегрированном коде, что не откладывает интеграцию.

**Скорость цикла обратной связи** - разработчик должен интегрировать только те изменения, которые не нарушают существующие тесты. В идеале он запускает все тесты перед интеграцией. Чтобы это было возможно, тесты должны выполняться очень быстро. Если они будут медленными, разработчик отложит интеграцию, чтобы "работать более эффективно". Однако быстро выполнить все тесты непростая задач для больших систем. Поэтому разработчики запускают только часть тестов перед слиянием кода, а CI-система запускает остальные тесты. CI-система действует как система безопасности, предоставляя разработчику информацию о тех тестах, которые он не проводил. Что происходит, когда CI-система работает медленно? Во-первых, в течение одного цикла произойдёт достаточно много изменений, что увеличит вероятность того, что сборка сломается. Во-вторых, разработчики не будут интегрировать свои изменения в сломанную сборку; Скорее, они будут их накапливать. Наконец, когда сборка исправлена, все разработчики интегрируют свои накопленные изменения, что повышает вероятность повторного обрушения сборки. Поэтому цикл проверки изменений должен быть быстрым. Это уменьшает вероятность поломки билда и увеличивает возможность более частого слияния кода.

Практическое правило для крупных продуктов, переходящих на гибкую и бережливую разработку: все разработчики интегрируются по крайней мере ежедневно. Несмотря на то, что "*ежедневная сборка для слабаков*" [Jeffries04](http://www.amazon.com/Extreme-Programming-Adventures-Developer-Reference/dp/0735619492), *интегрироваться ежедневно* - это первый шаг для таких продуктов. Вспомните метафору "озеро и скалы", используемую в бережливом мышлении. Большой камень - отсутствие возможности сделать сборку системы раз в день, *учтя изменения всех разработчиков* - является достаточно тяжёлым препятствием в больших старых системах с тремя сотнями программистов в четырёх странах. В конце концов, если удалить этот камень, то становятся возможными более короткие циклы обратной связи.

В больших продуктах потребуется время, чтобы научиться разбивать изменения, упростить процесс интеграции и настроить быструю CI-систему, которая ...

## Сохраняет основную ветку в рабочем состоянии

Разработчики интегрируются на *основной* или *trunk-ветке* [[BA03](http://www.amazon.com/Software-Configuration-Management-Patterns-Integration/dp/0201741172)]. Разработка в отдельной ветке ведёт к тому, что интеграция с основной веткой откладывается<sup>3</sup>. Текущее состояние билда не прозрачно, поэтому вы не знаете, работают ли все изменения вместе.

Ветвление во время разработки идёт в разрез с предназначением CI и его следует избегать. Но есть исключения: во-первых, клиенты, возможно, не захотят обновить свой продукт до последней версии, но все же захотят получить некоторые исправления. Таким образом, необходимы *ветки релизов*.<sup>4</sup> Во-вторых, при масштабировании CI-системы может быть полезным иметь *быстроживущие* ветки, которые автоматически интегрируются в основную - подробнее об этом ниже.

А что если, использовать ветвления для кастомизации? Плохая идея. Управляйте этим при помощи конфигурации или параметризованной сборки вместо использования Системы Управления Конфигурацией ПО (SCM). Однажды мы работали над продуктом для оптимизации сети, разработка которого велась в колоцированной продуктовой группе. Они настаивали на создании веток для различных конфигураций. Разработчики работали над такими отдельными ветками более года. После этого им потребовалось *ещё полгода* - и много усилий - чтобы слить их в trunk.

Успешная разработка в основной ветке ...

## Поддерживается CI-системой

Бережливое производство выделяет минимизацию запасов, которые являются одним из видов потерь. Запасы действуют, как буфер (очередная очередь), в котором скрыты ошибки. Ошибки становятся болезненно видимыми, когда такие буферы удалены - и это хорошо. То же самое происходит, когда все изменения интегрированы непосредственно в основную ветку. Все разработчики часто обновляют свои локальные копии; когда кто-то размещает неработающий код, он виден всем и является раздражителем.

Люди делают ошибки, это нормально. Страхующая сеть в бережливом производстве может дать сигнал для остановки всей производственной линии и нужна, чтобы обнаруживать такие ошибки как можно раньше. Разработчики исправляют ошибки до того, как это оказало влияние на всех. Такая страхующая сеть, похожая на Андон-систему (систему сигнальных фонарей) в терминологии Тойоты, и есть CI-система.

![continuous-integration-system.png](https://less.works/img/technical-excellence/xcontinuous-integration-system.png.pagespeed.ic.DysQv02fuw.webp)

___
CI-система
___

Система CI (см. CI-система) подключена к SCM. Когда разработчик публикует изменения, система CI проверяет весь код, компилирует его, запускает несколько тестов, устанавливает его и запускает дополнительные тесты. Все это происходит быстро. Экстремальное программирование рекомендует это делать не более десяти минут. Если разработчик ломает сборку, система CI запросит выяснит через SCM, кто внёс это изменение. Она посылает ему электронное письмо со словами: «Вы сломали сборку, исправьте её!». Исправление сломанной сборки является приоритетом номер один, потому что это затрагивает всех.

Для небольшого продукта не составляет труда иметь быструю десятиминутную сборку. Для большого продукта с унаследованным кодом и большой команды это довольно сложная задача. Позже в этой главе рассматриваются несколько методов масштабирования CI-систем...

## C большим количеством автотестов

Не так сложно, чтобы CI-система все компилировала; это также не очень полезно. Вам необходимо, чтобы в вашей системе CI выполнялось как можно больше тестов. Чем больше автоматических тестов, тем лучше ваша страхующая сеть и тем больше уверенность в работе вашей системы.

Для новых продуктов создание автоматизированных тестов не является сложной задачей. Однако многие крупные продукты имеют устаревший код без автоматизированных тестов. Разработчики должны добавить автоматизированные тесты - это большая работа. Глава об устаревшем коде описывает это.

## Масштабирование CI-систем

Во-первых, сборка и тестирование должны быть полностью автоматизированы. Многие продуктовые группы, с которыми мы работали, имели ручную сборку. Смотрите раздел "Рекомендуем к прочтению" для получения информации об автоматизации сборки.

Препятствия для масштабирования CI-систем связаны с большим количеством людей, производящих больше объёма кода и тестов. Во-первых, вероятность разваливания сборки увеличивается, когда все больше людей публикуют код. Во-вторых, увеличение размера кода приводит к более медленной сборке и, следовательно, к более медленной петле обратной связи CI. Вместе они могут привести к непрерывному отказу сборки (см. Динамику сломанных сборок).

![continuous-integration-causal-loop-ci-number-of-people.png](https://less.works/img/technical-excellence/xcontinuous-integration-causal-loop-ci-number-of-people.png.pagespeed.ic.MKkIa2srKL.webp)
___
динамика сломанных сборок
___

Есть несколько простых решений:
 - Ускорить сборку
 - Создать многоэтапную CI-систему.
 
Задача первая: ускорить сборку. Если весь продукт может быть скомпилирован и протестирован в течение одной секунды, то масштабирование будет избыточным. Односекундная сборка пока недоступна для крупных продуктов. Хотя каждое улучшение приближает нас к такой сборке за одну секунду. Дать общие рекомендации по ускорению сборок сложно - это часто зависит от продукта. Некоторые общие решения [[Rasmusson04]](http://link.springer.com/chapter/10.1007%2F978-3-540-27777-4_2):
- Увеличьте аппаратные ресурсы
- Распараллельте вычисления
- Поменяйте инструменты
- Собирайте инкрементально
- Разворачивайте инкрементально
- Управляйте зависимостями
- Занимайтесь рефакторингом тестов

**Увеличьте аппаратные ресурсы** - самый простой способ ускорить сборку - это купить больше "железа". Добавьте пару дополнительных машин, дополнительную память или ускорьте сетевое соединение, и проблема исчезнет. Обновление существующего оборудования требует инвестиций и минимальных усилий, что делает его самым простым и лучшим выбором. Сборка одного телекоммуникационного продукта ускорилась на 50 процентов за счёт компиляции на RAM-диске - и это потребовало только обновления памяти.

**Распараллельте вычисления** - связанная с предыдущим пунктом активность, заключается в распараллеливании и разнесении сборки. Это часто требует переработки сценариев сборки, смены или даже создания новых инструментов. Следовательно, требуется больше усилий по сравнению с простым добавлением нового оборудования. Крупный телекоммуникационный продукт ускорил их сборку, начав собирать каждый компонент на отдельной машине.

**Поменяйте инструменты** - обновление инструментов до последней версии или замена медленных на более быстрые ускоряет сборку. Просто пробуя разные компиляторы, мы однажды уменьшили время компиляции на 50 процентов. Наиболее распространённой проблемой, с которой мы сталкиваемся, является медленный IBM Rational ClearCase. Каждый раз, когда продуктовая группа переходила с ClearCase на Subversion - хорошую бесплатную систему SCM с открытым исходным кодом - они ... *Во-первых*, ускоряли сборку (наши клиенты увидели улучшение на 25-50%); *Во-вторых*, экономили компании значительные деньги за счёт отказа от лицензий; И *в-третьих*, улучшали жизнь разработчикам, поскольку ClearCase часто является самым ненавистным инструментом разработки в продуктах, с которыми мы работаем. Некоторые люди обладают неточной информацией и ошибочно утверждают, что Subversion не подходит для разработки крупных продуктов. Но мы видели, что он успешно используется в продуктовых группах с четырьмя сотнями человек, расположенных в разных точках земного шара. По иронии судьбы, так называемые крупномасштабные функции ClearCase, такие как поддержка нескольких площадок, делают реальный CI невозможным, потому что они усиливают кусочное владение кодом.

**Собирайте инкрементально** - вам нужно только скомпилировать изменившиеся компоненты и запустить соответствующие тесты. Легко в теории - трудно на практике. Зависимости между компонентами, изменения в интерфейсах или несовместимые бинарные файлы - вот некоторые вещи, которые затрудняют такую компиляцию. По тем же причинам поиск всех тестов, связанных с изменённым компонентом, может быть затруднён. Инкрементные сборки редко дают 100-процентную уверенность, и для предотвращения падения сборки всего приложения рекомендуется также собирать чистый билд ежедневно.

**Разворачивайте инкрементально** - в больших встраиваемых системах развёртывание или установка программного обеспечения может занимать достаточно большое время; система в области телекоммуникаций и радиосетей, с которой мы работали, занимала больше часа для развёртывания. Это не является чем-то необычным. Тестирование ускоряется, когда развёртывание выполняется постепенно - развёртываются только изменённые компоненты. Изменения становились доступными только после перезагрузки системы. Однако запуск большой системы занимает много времени, и поэтому некоторые системы обновляются динамически - важная функция в телекоммуникационной и других отраслях, где простои очень дороги. Инкрементное развёртывание - особенно динамическое обновление - требует изменений в системе, что является не самым простым вариантом.

**Управляйте зависимостями** - неуправляемые зависимости являются частой причиной медленных сборок. Примеры: header-файлы, включающие множество других header-файлы, или несколько циклов ссылок для разрешения циклических ссылочных зависимостей. При разработке мультимедийного продукта мы потратили несколько часов на переупорядочение ссылочных зависимостей - сократив время линкования вдвое. Уменьшение зависимостей ускоряет сборку и, как побочный эффект, улучшает структуру вашего продукта.

___
*Обратите внимание на ключевую идею*
Улучшение сборки улучшает структуру вашего продукта. Почему? Потому, что плохая структура становится сразу видимой, когда вы пытаетесь сократить время цикла сборки.

Об этом уже говорилось ранее: мощным побочным эффектом сокращения времени цикла является необходимость значительного улучшения процессов и продукта для поддержки коротких циклов и небольших партий.
___

**Занимайтесь рефакторингом тестов** - к сожалению, многие разработчики меньше заботятся о коде тестов, чем о продуктивном коде. Какой результат? Плохо структурированный код тестов и их замедление. Однажды мы потратили всего полдня на рефакторинг тестов - и ускорили сборку на 60 процентов! Путём профилирования и рефакторинга тестов вы можете быстро получить подобное преимущество.

Многоэтапная CI-система разбивает сборку и выполняет её в разных циклах обратной связи. На самом низком уровне она имеет очень быструю CI-сборку, содержащую модульные тесты и некоторые функциональные тесты. Когда эта сборка завершается успешно, она запускает сборку более высокого уровня, содержащую более медленные системные тесты. Большие продукты имеют ещё больше этапов.

Система CI сравнима с культурой «остановить-линию» в Toyota. Когда дефект обнаружен, Toyota останавливает линию, первым приоритетом становится устранёние дефекта и его первопричины. Разве многоступенчатая CI-система скрывает дефекты и противоречит этому принципу бережливого производства? Нет. Принцип «останови линию» в действии, но это не значит, что вы должны слепо остановить всю работу. Даже Toyota этого не делает [[LM06a](http://www.amazon.com/Toyota-Way-Fieldbook-Jeffrey-Liker/dp/0071448934)].
    
> Toyota разработала систему, которая позволяет выявлять и устранять проблемы, не останавливая линию. Когда проблема обнаружена и верёвка натягивается, звучит сигнал тревоги и загорается жёлтый индикатор. Линия будет продолжать двигаться до конца этапа текущего этапа производственного процесса - точки «фиксированной остановки»… линия остановится, когда будет достигнута такая точка, и Андон загорится красным.

Многоэтапной CI-система  работает аналогично. Вы выявляете проблему на раннем этапе и решаете её, но не хотите, чтобы она затрагивала всех. Только если проблема окажется действительно серьёзной, вы «остановите линию».

При построении многоэтапной CI-системы подумайте над:
 - сборкой для разработчиков
 - фокусом на фичах или компонентах
 - автоматическим или ручным "продвижением"
 - запуском по событию или расписанию
 - количеству этапов

**Сборка для разработчиков** - разработчики, практикующие CI, должны проверить свои изменения перед слиянием изменений. Следовательно, они должны уметь работать с частью системы, часто с одним из её компонентов, и иметь возможность запускать для него модульные тесты. Примите это во внимание при автоматизации вашей сборки.

**Фокус на фичах или компонентах** - традиционная многоэтапная система CI построена вокруг компонентов. На самом низком уровне собирается один компонент, на следующем уровне - подсистему, а на самом высоком уровне - весь продукт. Каждая команда, организованная вокруг компонента, заботятся о только своей собственной CI-системе [[AKB04](https://www.cmcrossroads.com/article/continuous-staging-scaling-continuous-integration-multiple-component-teams)]. Но каком этапе включить приёмочные тесты более высокого уровня, а как насчёт фиче-команд? Альтернативой является структурирование вашей системы CI как раз вокруг фич. Когда кто-то публикует изменения кода, все соответствующие системы CI-компонентов запускаются. Теперь тесты выполняются параллельно, но один и тот же компонент компилируется несколько раз.

Одна территориально распределённая продуктовая группа, с которой мы работали, использует два подхода. На более низком уровне CI-система организована вокруг компонентов, а их окончание является триггером для запуска мультифункциональных этапов CI-системы, выполняющих высокоуровневые приёмочные тесты параллельно.

**Автоматическое или ручное "продвижение"** - подключение всех этапов CI к основной ветке создаёт беспорядок. Когда разработчик делает ошибку, все этапы сборки сразу падают. Система CI более высокого уровня должна запускаться после сигнала о том, что компоненты собраны и готовы для использования. Такой сигнал называется *"продвижением"* и может быть создан путём маркировки (или тегирования) компонента. "Продвижение" выполнятся автоматически или вручную [[Poole08](http://damonpoole.blogspot.com/2007/12/multi-stage-continuous-integration.html)]. При автоматическом продвижении CI-система нижнего уровня "продвигает" компонент после прохождения всех проверок. Избегайте ручного продвижения, при котором команда сама решает, когда компонент «достаточно хорош», и продвигает его.

**Запуск по событию или расписанию** -  каждая CI-система запускается либо по событию, либо по расписанию. Системы CI низкого уровня всегда запускаются по событию - изменению кода в репозитории. Для систем CI более высокого уровня триггером является либо "продвижение" компонента, либо расписание. Запуск при продвижении быстрее, но для медленных сборок он не стоит дополнительных усилий по настройке и обслуживании. Дневная сборка более высокого уровня может быть достаточной для таких ситуаций [[Vodde08](http://www.odd-e.com/material/2008/crosstalk/200805-Vodde.pdf)]. Например, одна распределённая продуктовая группа, с которой мы работали, имела низкоуровневые CI-системы, запускаемые при изменения кодовой базы, а высокоуровневую CI-систему, запускаемую "продвижением", и ежедневные тесты, выполняемые в течение восьми часов.

**Количество этапов** - размер и степень «унаследованности» продукта определяют, сколько уровней систем CI необходимо. Общие этапы могут быть следующими:
 - *быстрый уровень компонентов* - очень быстрая низкоуровневая CI-система для получения быстрой обратной связи. Она запускает модульные тесты, рассчитывает покрытие кода, проводит статический анализ и измеряет цикломатическую сложность кода.
 - *медленный уровень компонентов* - более медленная низкоуровневая CI-система. Она запускает интеграционные или медленные тесты на уровне компонентов.
 - *уровень проверки стабильности всего продукта* - очень быстрая CI-система уровня продукта для получения быстрой обратной связи о стабильности всего продукта. Она запускает быстрые функциональные тесты (smoke-тесты).
 - *системный уровень* - медленная высокоуровневая CI-система. Она запускает системные тесты, которые часто могут занимать несколько часов.
 - *уровень нагрузочного тестирования* - очень медленная CI-система  высокого уровня. Она постоянно проводит тесты на стабильность и нагрузку, которые занимают дни, если не недели.

Нам ещё предстоит увидеть все этапы в одном продукте. Большинство продуктов выбирают наиболее важные для них этапы и добавляют остальные только при необходимости. Неоправданно сложная CI-система  - пустая трата времени.

#### Пример многоэтапной CI-системы

Иллюстрация "Масштабированная CI-система" показывает пример поэтапной системы CI. В этом примере каждый компонент имеет свою CI-систему , выполняющую модульные тесты, статический анализ кода и рассчитывает показатели покрытия кода. Успешная сборка "продвигает" компонент и запускает CI-системы уровня фич, выполняющие высокоуровневые тесты. Ежедневная сборка выполняет системные тесты, такие как нагрузочные тесты.

![continuous-integration-scaled-system-example.png](https://less.works/img/technical-excellence/xcontinuous-integration-scaled-system-example.png.pagespeed.ic.S4KIbYX_3o.webp)

___
Масштабированная CI-система.
___

CI-система может эффективно поддерживать визуальное управление - один из принципов Бережливого Производства. Когда сборка падает, визуальный сигнал указывает на отказ - *Андон*-система (в терминологии Toyota). Цель не в том, чтобы менеджеры наказывали разработчика, который сломал сборку; наоборот это инструмент для разработчиков, чтобы они могли видеть статус сборки. Что они будут делать с этой информацией? Изучить, что происходит, или отложить их интеграцию в случае сбоя сборки. Если через некоторое время визуальный сигнал все ещё указывает на сбой, большее количество людей может подключиться к поиску причин, почему он ещё не устранён.

Раньше было популярным в качестве визуального инструмента использовалась лавовая лампа, подключённая к CI-системе. Зелёная пузырящаяся лавовая лампа указывала на успешную сборку. Но когда сборка не удавалась, красная лавовая лампа начинала пузыриться.

После лавовых ламп люди начали подключить к CI-системам всевозможные визуальные эффекты, такие как рождественские огни, сирены и движущиеся скелеты, которые кричали, когда сборка не удавалась. Хотя пример с простым монитором и веб-страницей красного или зелёного цвета (красно-зелёный экран) менее интересен, но такой способ проще повторить. Красно-зелёные экраны, кажется, стали вездесущими в крупномасштабных CI-системах. В некоторых версиях имеется жёлтый сигнал, указывающий на то, что повреждённая сборка в процессе исправления. Простой большое цветовое пятно, видимое на расстоянии, является ключевым элементом, но на дисплее также можно добавить текст или данные диаграмм, таких как продолжительность сборки или покрытие тестами. Информацию можно ограничивать лишь информацией о сборке [[Rogers08](http://www.hanselminutes.com/default.aspx?showID=131)].

![continuous-integration-andon-skeleton.jpg](https://less.works/img/technical-excellence/xcontinuous-integration-andon-skeleton.jpg.pagespeed.ic.PuB-qPPam_.webp)

![continuous-integration-andon-red-green.jpg](https://less.works/img/technical-excellence/xcontinuous-integration-andon-red-green.jpg.pagespeed.ic.5N9GjbchL1.webp)

Одно предупреждение, относящееся к визуальному управлению, хорошо сформулировано Джеффри Лайкером [[LH08](http://www.amazon.com/Toyota-Culture-Heart-Soul-Way/dp/0071492178)]:

> То, что есть визуальное представление, не означает, что есть и визуальный менеджмент. Относительно легко настроить красивую визуализацию. Сложнее всего сделать их «ежедневным движением». Многие люди, которые посещают заводы Toyota, открыто озвучивают разницу в их подходе. Мы часто слышим комментарии, такие как «Теперь я вижу, что то, что демонстрирует Toyota, на самом деле является ежедневной движущей силой». Это действительно различие, и Toyota может предложить, чтобы, если это не управляет повседневными действиями, то нужно от это избавиться.

## Заключение

## Рекомендуем к прочтению

## Сноски

1. [CruiseControl.NET](http://cruisecontrol.sourceforge.net/) - это CI-сервер для платформы for Microsoft .NET.
2. Для разработки на Java 10 минут - это слишком много. Для C++ в среднем нормально. Для C, возможно даже мало. 10 минут - среднее время TDD-цикла независимо от языка и платформы.
3. Чтобы быть более точным, избегайте веток, которые живут дольше нескольких часов. Работа с ветками становится проще при использовании современных систем контроля версий, таких как Git или Mercurial. Иногда использование быстроживущих веток может быть полезным... но это опасный инструмент, который можно с лёгкостью использовать неправильно [[Fowler09](http://martinfowler.com/bliki/FeatureBranch.html)].
4. Совет: Создавайте релизные ветки перед самым выпуском релиза, а не при начале его разработки.