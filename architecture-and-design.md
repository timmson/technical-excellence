# Архитектура и Проектирование / Architecture & Design

| Источник | Статус |
| - | - |
| [Ссылка](https://less.works/less/technical-excellence/architecture-design.html) | *В работе* |

## Содержание

- [Введение](#Введение)
- [Размышления о проектировании](#Размышления-о-проектировании)
- [Процессные рекомендации](#Процессные-рекомендации)
- [Инженерные рекомендации](#Инженерные-рекомендации)
- [Заключение](#Заключение)
- [Полезные ссылки](#Полезные-ссылки)
- [Сноски](#Сноски)

## Введение

> Существует 10 типа людей: кто понимает двоичный формат и кто нет.
> -- неизвестный автор

В ландшафтной дизайне существует эволюционная методика проектирования с использованием
["протоптанных тропинок"](https://en.wikipedia.org/wiki/Desire_path).

![desire_line.jpq](https://less.works/img/design_&_architecture/xdesire_line.jpg.pagespeed.ic.w8uuycckG8.webp)

**Проблема**: Где проложить дорожки для прогулок в новом парке? Какими широкими они должны быть?

**Решение**: Подождите год и наблюдайте за тем, как люди естественным образом гуляют там, где им удобно. Создавайте дорожки
вдоль этих "протоптанных тропинок" такими широкими, насколько часто по ним гуляют. Дизайн подчиняется спросу, а не задается
заранее. Несмотря на сложность применения в проектировании ПО, описанный выше подход является одним из источников вдохновения
при бережливой или гибкой разработке, а также является одним из вариантов *эмерджентного проектирования*<sup>1</sup>.

Вероятно, это тема для толстой книги, например "Масштабное Гибкое Проектирование", но это не так. Это не трактат о
техническом дизайне; он предлагает несколько процессных советов, связанных с проектированием и крупномасштабной гибкой
разработкой, с несколькими заслуживающими внимания техническими советами - некоторые из которых аналогичны "протоптанным
тропинкам". Некоторые советы отражают принципы бережливой разработки программного обеспечения, такие как "решить в последний
ответственный момент" (decide at the last responsible moment). Некоторые отражают принципы
[Манифеста Гибкой Разработки ПО](https://agilemanifesto.org/iso/ru/manifesto.html), такие как "Непосредственное общение
является наиболее практичным и эффективным способом обмена информацией как с самой командой, так и внутри команды". Также многие
рекомендации поддерживают девятый принцип этого манифеста: "Постоянное внимание к техническому совершенству и качеству 
проектирования повышает гибкость проекта".

## Размышления о проектировании

### "Выращивание", а не "строительство" - Создавайте культуру живого, растущего дизайна системы

Мы хотели назвать этот раздел просто *Проектирование*, но решили остановиться на названии *Архитектура и Проектирование*
из-за существующей веры в то, что программный код, дизайн и архитектура должны быть *разделены*, и поэтому "создание
архитектуры" и программирование - тоже разделены<sup>2</sup>.

Слово "архитектура" в английском языке имеет, по крайней мере, два значения в общем понимании в области разработки ПО:

- (сущ.) крупномасштабные статические и динамические структуры и шаблоны
    - также *необходимая архитектура* (предполагаемая, желаемая) по сравнению с *текущей* - которая может быть не достижима

- (гл.) создание и определение предполагаемой архитектуры, как в "подготовка архитектуры" или "когда вы будете готовить
архитектуру?"
    - выполняется один раз в начале проекта
    - часто в документах пересекается с анализом требований.

Термин был заимствован у "классических" архитекторов, которые проектируют материальные объекты: здания и сооружения. Такая
аналогия<sup>3</sup> становится слабо применимой, обладая интересными побочными эффектами для разработки программного
обеспечения. Здания являются "твердыми" (hard), и поэтому в этой области проектирование архитектуры выполняется только один
раз перед началом строительством - по крайней мере, в наши дни - и затем они почти не меняются. Отметим также, что
архитекторы и конечные строители - разные группы людей.

Но программное обеспечение - это не здание, программное обеспечение "мягкое" (software - soft), а *программирование - это
не процесс **строительства***; "Архитектура программного обеспечения" - это всего лишь еще одна несовершенная аналогия из большого
списка возможных метафор.

Какие еще метафоры применимы? Можно процитировать статью
[Джека Ривза "Что такое дизайн программного обеспечения?"](http://www.developerdotstar.com/mag/articles/reeves_design.html)

> … Единственная документация, которая на самом деле описывает достоверно дизайн системы, это ее исходный код

По мнению Крейга Лармана, со-создателя LeSS и автора [книги по анализу программного обеспечения, проектированию,
моделированию, шаблонам и архитектуре](https://www.amazon.com/Applying-UML-Patterns-Introduction-Object-Oriented/dp/0131489062)
, работавшего с 1970-х годов в качестве программиста, диаграммы и документы - это не настоящий дизайн, настоящий дизайн -
это также исходный код.

Исходный код (на языке C, C ++, ...) является настоящим "проектным планом". И только в контексте программного обеспечения
"Сборка" ("билд", Build) или сборка практически бесплатны и мгновенны<sup>4</sup>. Следовательно, многие не видят его таким,
какой он есть: Сборка - это этап компиляции и компоновки. Не случайно, что в инструментах разработки пункт меню для запуска
компиляции называется "Сборка".

![build_menu.jpq](https://less.works/img/design_&_architecture/xbuild_menu.png.pagespeed.ic.UcDpOxTQ09.webp)

**Сценарий**: В первые дни существования Продукта Х предположим, что существовали высокоуровневые проектные документы для
крупных элементов системы, идиом и взаимодействий в рамках предполагаемой архитектуры, и предположим, что реальный дизайн
(исходный код) хорошо отражает эти требования. Прошло семь лет и все программисты, которые начинали разработку, больше не
работают, а были наняты 300 новых не очень квалифицированых разработчиков, которые на самом деле не знают или не думают о
первоначальных концепциях высокоуровневого дизайна. Представьте, что они добавили 9,5 миллионов строк кода (9,5 MLOC),
предположим, что это 95 процентов всего кода - и это источник путаницы.

Где *настоящая архитектура* - хорошая или плохая, намеренная или случайная? В документах, поддерживаемых (или нет)
группой архитектуры, или в 10 миллионах строк (10 MLOC) C/C++ кода в десятков тысяч файлов? Очевидно, что последнее -
исходный код является *реальным дизайном*, и только он отражает истинный крупномасштабный дизайн или архитектуру. Архитектура
- это то, что есть, а не то, что хочется. "Архитектура" в программной системе не обязательно является хорошей или намеренной.

**Первое наблюдение** - *Сумма всего исходного кода - это настоящий архитектурный план проекта или программная архитектура.*

Дизайн / код программного обеспечения улучшается или ухудшается с каждым днем, с каждой строкой кода, добавляемой или
изменяемой разработчиками. Архитектура программного обеспечения не является статичной вещью. Программное обеспечение - это
живое существо, больше похожее на растение или сад, чем на здание, и живой дизайн или архитектура день ото дня становятся
лучше или хуже.

**Второе наблюдение** - *Реальная архитектура программного обеспечения развивается (становится лучше или хуже) каждый день
жизни продукта, так как люди меняют исходный код.*

Аналогия с [садоводством, парками и растениями является полезной](http://www.amazon.com/Pragmatic-Programmer-Journeyman-Master/dp/020161622X).
Например, существует ландшафтная архитектура существительного и глагола - это нормально и умело учитывать и "проектировать"
общую картину при планировании большого сада или парка. И все же люди не оставляют это при этом. Из-за видимой природы парка
и из-за того, что растения растут, кристально ясно, что фактическая ландшафтная архитектура быстро превратится в джунгли
сорняков без постоянного садоводства или обрезки от практических садоводов, помня об оригинальном или развивающемся видении
парка , У нас есть друг, который работает ландшафтным архитектором для полей для гольфа. Он видит своими глазами детали
реального, живого курса, пока он создается, обходит его и играет в гольф - в связи с реальностью того, что есть.

Этот переход от метафоры архитектуры программного обеспечения к ее *выращиванию*, как растения, повлиял на многих людей,
размышляющих об успешной разработке. Например, Фредерик Брукс в своей известной статье
["Нет серебряной пули"](http://www.cs.nott.ac.uk/~cah/G51ISS/Documents/NoSilverBullet.html) делится своим пониманием:

> Метафора "строительства" исчерпала свою полезность... Если, как я полагаю, концептуальные структуры, которые мы строим
> сегодня, слишком сложны, чтобы их можно было точно определить заранее, и слишком сложны, чтобы их можно было безошибочно
> построить, тогда мы должны использовать радикально иной подход... Секрет в том, что это **выращено, а не построено**...
> Харлан Миллс предложил, чтобы любая программная система росла путем поэтапной разработки... Ничто за последнее десятилетие
> так радикально не изменило мою собственную практику или ее эффективность...

**Третье наблюдение** - *Реальную живую архитектуру нужно выращивать каждый день под руководством экспертов-разработчиков.*

**Четвертое наблюдение** - *Архитектор программного обеспечения, который не имеет отношения к меняющемуся исходному коду
продукта, оторван от реальности.*

**Пятое наблюдение** - *Каждый программист - это своего рода архитектор, независимо от того, хочет он этого или нет. Каждый
акт программирования - это своего рода архитектурный акт - хороший или плохой, маленький или большой, намеренный или нет.*

Какое это имеет отношение к масштабированию разработки и гибкости?

В небольшой продуктовой группе, состоящей из 20 человек, люди хорошо понимают вышесказанное, и редко существует узаконенная
ложная дихотомия или разделение между архитектурой и программированием. Кроме того, если есть официальный "архитектор", то
этот человек, как правило, тоже пишет код. Но в большой продуктовой группе с 600-ми сотрудниками на колоссальном предприятии
существует распространенная ошибка ментальной модели: проектирование или архитектура определенно отделены от кода и процесса
программирования. Следовательно, нередко можно найти отдельную команду архитектуры и/или системной инженерии, организованную
ими "архитектурную" ступеньку (до программирования), и ее члены не являются разработчиками-практиками или (по крайней мере,
не более) экспертами в написании кода мирового класса.

Эта группа архитекторов (или группа по системному проектированию) обычно содержит добрых и светлых людей. Но (должно быть,
но здесь), в традиционной организации они постепенно теряют связь с реальным кодом и становятся так называемыми
*PowerPoint-архитекторами*, *архитекторами из башен из слоновой кости* или
*[архитектурными астронавтами](http://www.joelonsoftware.com/articles/fog0000000018.html)* - настолько далекими и
отвлеченными от кода реальных систем, что они находятся в космическом пространстве.

Какие могут быть последствия? В большой продуктовой группе с (1) ментальной моделью, согласно которой неподходящая метафора
архитектуры и строительства ПО, такой как здание, считается хорошей метафорой; (2) отсутствие понимания того, что истинная
архитектура находится в исходном коде; и, (3) кадровый состав архитектурных астронавтов, все это иронично приводит к
деградации архитектуры с течением времени. Зачем? Некоторая динамика в игре показана в модели системной динамики на рисунке
ниже. Обратите внимание на несколько положительных петель обратной связи, которые могут усиливать ухудшение или улучшение со
временем.

![dynamics_related_to_architecting_metaphoor.png](https://less.works/img/design_&_architecture/xdynamics_related_to_architecting_metaphoor.png.pagespeed.ic.Xuf0bZleqa.webp)

CLD иллюстрирует метафору "архитектура"
___

Кроме того, что происходит с кодом - реальным дизайном - в группе со следующей культурной ценностью и общим настроением?...
*Там есть группа архитектуры; Вы обычные программисты, а не архитекторы.* Программисты естественно чувствуют, что архитектура
не является их ответственностью, и деградация архитектурной целостности продолжается.

Если системная динамика увеличивает влияние PowerPoint-архитекторов, то в результате они оказывают влияние, уменьшающееся
со временем, так как они не связаны с реальным кодом. В конце концов они теряют связь и в конечном итоге пишут документы друг
для друга или для заинтересованных сторон. Настоящие "случайные" архитекторы (программисты) в основном их игнорируют.

Однажды у нас была беседа с опытным программистом, который написал драйвера для сетевых процессоров, которые являются частью
очень большого продукта. Он был обеспокоен тем, что архитекторы из башни из слоновой кости, расположенные на два этажа выше,
буквально *в другой башне*, выбрали новый сетевой процессор, который потребует полного переписывания всех драйверов - по
оценкам, это будет как минимум девять месяцев работы по написанию кода. И это даже не учитывало тестирование и разрешение
неожиданных проблем нового семейства процессоров. Написав драйвера для многих процессоров, разработчик был экспертом в этой
области, и он согласился, что новый процессор лучше - по крайней мере, на бумаге. Тем не менее, он также знал, что 
модернизация существующего процессора до более новой модели в том же семействе даст почти те же преимущества, и при этом не
потребуются никакие усилия для замены существующих драйверов. Он серьезно сомневался, что архитекторы из башни из слоновой
кости знали об усилиях и влиянии на разработку программного обеспечения - никто из них не говорил с ним; фактически они не
общались с настоящими программистами.

*Архитектурный фундамент?* - "Важно иметь архитектурный фундамент, прежде чем реализовывать что-либо еще, иначе у вас не
будет архитектурного фундамента". Эта ложная дихотомическая идея проистекает из метафоры здания, как будто программная
система была сделана из бетона, а не из "мягкого" кода. Но основные элементы системы все таки не могут быть улучшены с
помощью циклов обучения и рефакторинга. По совпадению, когда мы писали этот раздел, мы пили пиво пабе в Оксфорда, в Англии,
с Алистером Кокберном (лидером мысли в гибкой разработке), который сказал нам, что он и его жена хотят *добавить* подвал в их
существующий дом. Строители подняли весь дом, вырыли под ним подвал и поставили дом обратно. Удивительно, какие
"архитектурные" фундаментальные изменения возможны, если мыслить нестандартно, а программное обеспечение все же намного
мягче, чем дома.

Конечно, важно иметь отличную архитектуру. Очень важно, чтобы каждый акт гибкого моделирования и программирования для жизни
системы рассматривался как архитектурный акт. Мы все согласны с тем, что хорошая архитектура важна; вопрос в том, каким
способом достичь этого? Большинство советов в этом разделе содержат предложения о том, как создать и поддерживать отличный
"фундамент", который не основан на метафоре здания или последовательном жизненном цикле.

Нет ложной дихотомии: предварительное моделирование это нормально, документы, описывающие предполагаемую архитектуру, тоже,
и так далее. Но архитектура и наши знания об этом могут меняться. Спекулятивная архитектура программного обеспечения должна
быть конкретной, а не конкретной (???)

___
**Гибкая архитектура основывается на гибком поведении при проектировании - опытных архитекторов-программистов,
культуре совершенства в коде, упоре на обучении во время парного программированию для получения высококачественного кода/
проектирования, воркшопах по проектированию и гибкому моделированию, разработке на основе тестов, рефакторинге и других
инженерных практиках.**
___

## Процессные рекомендации

### Воркшопы по проектированию и моделированием

Воркшоп по *сбору требования* объединяет пользователей и разработчиков, что они могли встретиться лицом к лицу. Они
(воркшопы) чрезвычайно полезны не только для лучшего изучения потребностей пользователей, но и, что является ключевым
моментом, для создания общего понимания среди всех участников.

Такие же преимущества дает *воркшоп по проектированию*. В отличие от воркшопа по сбору требований, в нем не участвуют
клиенты, но все члены команды разработки (люди обладающие навыками программирования, системного проектирования,
архитектуры, тестирования, проектирования пользовательского интерфейса, проектирования баз данных и т. д.) должны принимать
в нем участие.

**Когда?** - Подумайте о проведении воркшопов по проектированию в начале создания каждого нового элемента (например, три
воркшопа по проектированию для каждого из трех элементов в итерации) и точно-во-срок тогда, когда команда найдет решит, что
необходимо перейти к моделирования на "стенах".

![design_ws_1.jpg](https://less.works/img/design_&_architecture/xdesign_ws_1.JPG.pagespeed.ic.Wl7jAB8HRM.webp)

воркшоп по проектированию - фиче-команды моделируют на "белой доске" в общекомандном пространстве
___

**Что моделировать?** - Во время воркшопа по проектированию фиче-команды фокусируются на моделировании, связанном с их
предстоящими задачами или общей архитектурой системы или даже с обоими. Так происходят все виды проектирования и
моделирования: проектирование пользовательского интерфейса с помощью набросков и заметок или инструментов для создания
прототипов, моделирование алгоритмов с помощью UML-диаграмм, проектирование ООП-модели, обычно в нотации UML, и моделирование
базы данных аналогичным образом.

![gui_with_glue.jpg](https://less.works/img/design_&_architecture/xgui_with_glue.jpg.pagespeed.ic.WC8ffl0v_l.webp)

моделирование применимо и к пользовательскому интерфейсу
___

Это не воркшоп по сбору требований. К тому времени, когда ваши команды соберутся на воркшопах по проектированию, вы должны
более или менее понимать требования к архитектуре. Естественно, всегда есть место уточнению требований или вопросам,
поднимаемых во время воркшопа по проектированию.

**Громадные "доски"** - Воркшопы по проектированию требует *огромного* пространства "белых досок". Стандартные доски обычно не
достаточны - и на самом деле часто являются препятствием, потому что моделирование лучше всего проводить на **всей
поверхности стен** *без границ*. Вы захотите покрыть практически все пространство стен материалом "белых досок", обычно
высотой около двух метров.

___
**За прошедшие годы проведения воркшопов по проектированию, мы заметили, что существует *линейная* зависимость между их
эффективностью и количеством места на доске.**
___

В магазинах канцелярских товаров или на их сайтах вы можете купить "электростатические доски" или "липкие доски", поверхность
которых похожа на обычную "белую доску", которые удерживаются с помощью электростатики или клея<sup>5<sup>. Вы также можете
купить "белые обои" - отличное решения для того, чтобы обклеить все пространство в комнате от пола до потолка. Одна компания,
в которой мы работали, купила дешевые стеновые ПВХ-панели для ванной комнаты, которые отлично работали в качестве досок; они
покрыли ими всю комнату. Как только такие пространства "досок" сформированы, их можно оставить в таком состоянии навсегда.

![cling_sheet_roll.jpg](https://less.works/img/design_&_architecture/xcling_sheet_roll.JPG.pagespeed.ic.8UluXs3XtV.webp)

**Лучший инструмент для моделирования?** – Я (Крейг Ларман) написал книгу *Применение UML и шаблонов проектирования*. Люди,
которые знают об этом, иногда спрашивают меня, какой **CASE** (computer-aided software engineering, средства
автоматизации разработки программ), MDD (model-driven development, разработка, управляемая моделями) или MDA (model-driven
architecture, "архитектура, управляемая моделями") инструмент я использую. Или, если я организую воркшоп по проектированию,
они могут спросить, как какой-либо из инструментов CASE/MDD/MDA настроить. Обычно они удивляются, когда я отвечаю: "Лучший
инструмент для моделирования, который я знаю - это свежая черная маркерная ручка, группа людей и гигантская область доски.
*Эскиз UML на стене* - это здорово".

Программные для построения UML иногда полезны, и в некоторых случаях мы рекомендуем их. Например, они могут пригодиться
для автоматического и быстрого преобразования кодовой базы в набор диаграмм (*реверсивного проектирования*), помогающих
увидеть общую картину. Но для *прямого проектирования* или генерации кода они могут не следовать трендам современной
разработки и помешать достижению ее целям <sup>6</sup>.

![uml_wall.jpg](https://less.works/img/design_&_architecture/xuml_wall.jpg.pagespeed.ic.OuWP8z_eVQ.webp)

полезный, простой UML на отличном UML-инструменте - на стене.
___

Совместное создание эскизов с помощью простого инструмента и испытанного временем многолетнего подхода являются одной из
дисциплин [гибкого моделирования](http://www.amazon.com/Agile-Modeling-Effective-Practices-Programming/dp/0471202827).

Оставляя в стороне другие советы и практики гибкого моделирования, зачем мы продолжаем моделировать на воркшопах?

**Моделирование заставляет общаться**

Это повторение *Первого Закона Диаграмм*, описанного в
[Системном Мышлении](https://less.works/less/principles/systems-thinking.html):

> Основное ценность диаграмм - это обсуждение во время построения диаграмм - мы моделируем для того, чтобы обсудить.

Мы призываем команды *не* создавать модели ради создания *спецификаций*, а *вести беседу* - вместе исследовать и обсуждать,
создавать общее понимание архитектуры и требований, помочь разработать общую ментальную модель и учиться вместе. Несомненно,
некоторые объектно-ориентированные UML-модели или прототипы UI на стенах в конечном итоге будут успешно реализованы в коде,
но это побочное преимущество, заключающееся в том, что вы найдете время подумать, обсудить и набросать идеи вместе.

**Модели - это не спецификации**. Любая модель, созданная до того, как код - это всего лишь предположение (и контекст для
разговора), а не реальная архитектура, которая существует только в исходном коде. В гибком моделировании справедливо
считается, что наброски и текст диаграммы являются *источником вдохновения*, а *не спецификацией*. Лучшая проектная документация
(для целей сопровождения) создается *после* завершения кода на SAD-воркшопах, описанной ниже.

**Все модели "неверны", и это нормально** - люди обсуждают, чтобы перенять новые идеи и выровнять свое и командное понимание
задач. Естественно, что модели "неверны" и дизайн развивается, когда люди попадают в реальность программирования и обучения.

**Фотографии, размещенные в вики**. Команды часто фотографируют эскизы стен и размещают их на вики-пространстве своего
продукта.

**Воркшопы по проектированию и архитектурная целостность**. В небольшой команде, состоящей из шесть человек, можно обойтись и
без семинаров по структурированной сессии по моделированию. По мере того как мы растем и становимся более крупной командой,
ценность группового моделирования для формирования общего понимания идей архитектуры все больше и больше становится ценными.
**Архитектурная целостность** является ключевой проблемой при масштабировании разработки. Поддержанию этой целостности
сводится к архитектурным идеям в головах программистов - они могут быть похожими так и нет. Воркшопы по проектированию
помогают выравниваться в понимании идей и сохранять архитектурную целостность.

**Снижение издержек и обучение.** В бережливом мышлении основное внимание уделяется сокращению издержек, а бережливая
разработка направлена на усиление конкурентного преимущества. Воркшопы по проектированию поддерживают эти цели следующим
образом:

- Воркшопы уменьшают *задержки* и *потери при передачи информации*. Раньше, чтобы проектировщик или архитектор создавали
проектную документацию и отправляли ее разработчикам<sup>7</sup> и получали отложенную обратную связь от них посредством
непрямых способ коммуникации. Вместо этого, воркшопы собирают всех вместе и дают возможность дать быструю обратную связь
напрямую. Это также поддерживает шестой принцип гибкой разработки - *Непосредственное общение является наиболее практичным и
эффективным способом обмена информацией как с самой командой, так и внутри команды.*
- Они сокращают потери информации, поскольку люди ведут живую беседу, обсуждая детали на доске.
- Они сокращают потери недостаточной востребованности людей, поскольку люди учатся друг у друга и, таким образом, расширяют
свои компетенции.
- Они улучшают знания, как с точки зрения обучения других, так и с точки зрения генерирования новых идей посредством
перекрестного обмена мнениями группы из семи человек, творчески исследующих проблемы вместе.
- В бережливой организации менеджеры и эксперты также являются учителями. Воркшопы по проектированию предоставляют для
руководителей отличную возможность для обучения других навыкам проектирования и архитектуры.
- Они помогают легче управлять процессом на основе визуализации.
- Они способствуют бережливым принципам построения консенсуса и кросс-функциональной интеграции.

![walls_in_halls.jpg](https://less.works/img/design_&_architecture/xwalls_in_halls.JPG.pagespeed.ic.7O1_iHz5Xm.webp)

Коридор - отличные место для размещения больших досок. Такие доски вовлекают других людей в практику гибкого моделирования,
когда они проходят мимо командой, активно занятой "у стен".
___

**Простые инструменты, творческий процесс, соучастие** - люди по своей конструкции не приспособлены, чтобы смотреть в
крошечные экраны мониторов и перемещать мышь. Люди созданы для *наскального искусства*. Попробуйте провести совместный
пятичасовой воркшоп по проектированию с семью людьми, *сидящими за компьютерами*. Это будет мертвая встреча. Но попробуйте
пригласить тех же самых людей в общее пространство с большими "досками", дайте им маркеры, и точно произойдет что-то хорошее
(особенно если они проходили обучение по гибкому моделирования). Эти простые приятные инструменты, особенно огромное
пространство на с доской, стимулируют *творческий процесс* и *соучастие*. Это важно.

**Простой UML** - поскольку люди хорошо воспринимают визуальную информацию ("пузыри и стрелки", а не просто текст), мы
призываем людей освоить некоторые основами нескольких UML-нотаций, включая диаграммы активностей, классов и взаимодействия.
Но подробные обозначения совершенно не важны - модель нужна для иллюстрации дискуссии, а не для создания спецификаций.

**Сколько времени может занять?** – от двух часа до двух дней. Как и во всех Scrum-событиях, заранее запланируйте время
воркшопы, чтобы люди могли спланировать свое время.

### Моделирование "Точно-в-Срок" (Just-in-Time, JIT); меняйте уровень абстракции

В дополнение к более крупным и длительным воркшопам по проектированию для всей команды рассмотрите следующий сценарий:
кто-то один или в паре программирует и "застревает" на сложном участке. Им нужна другая точка зрения. Мы часто видим, как
такая пара берет небольшой листок бумаги и рисует. Но если они работают в комнате команды, а все стены покрыты каким либо
типом "белой доски", то этот человек может встать, пригласить коллег и начать набрасывать и обсуждать следующие шаги. Это
может длиться от несколько минут до несколько часов. Это и есть *JIT-моделирование*.

Обратите внимание, что это позволяет людям легко и просто менять уровень абстракции - от кода к моделям и обратно.
Распространенная ложная дихотомия заключается в том, что единственное время для высокоуровневого проектирования системы -
это этап предварительной разработки. Но это не так. С практикой гибкого моделирования в окружении, удобном для этого, люди
могут постоянно переходить между уровнями абстракции.

### Воркшопы по проектированию каждую итерацию

Запланируйте и проводите, *по крайней мере, один* воркшоп по проектированию в каждой итерации ближе к ее началу. Если
потребуется, то можно провести дополнительные воркшопы для каждого элемента Бэклога Спринта. Он должен быть ограничен по
времени в диапазоне от двух часов до двух дней. На нем обычно рассматриваются задачи текущей итерации, хотя иногда
проектирование на несколько спринтов вперед тоже имеет смысл. Команда может провести небольшой воркшоп по проектированию
до реализации первой задачи, затем еще один семинар через четыре дня до реализации второй и так далее.

Для очень молодых систем иногда архитектура настолько неясна на ранних итерациях, что необходимо следующее: Предположим, что
это последняя неделя итерации. После прояснения элементов Бэклога Продукта (обычно оно происходит в середине текущей итераций, чтобы
разобрать элементы для будущих), также проведите воркшоп по проектированию, связанный с вероятными целями следующей итерации
или за ее пределами - если необходимо изучить крупномасштабные архитектурные проблемы. Это прояснит планы во время
планирования спринта в первый день следующей итерации.

### Воркшопы по проектированию на рабочих местах команд

Это полезно, если стены каждой командной команды покрыты электростатической пленкой, чтобы можно было проводить воркшопы по
проектированию. Когда разработчики сидят за рабочей станицей, они могут посмотреть на стены для понимания общей картины или
встать около такой стены, чтобы быстро что-то обсудить. Это помогает с легкостью проводить JIT-проектирование.

![design_ws-china.jpg](https://less.works/img/design_&_architecture/xdesign_ws-china.jpg.pagespeed.ic.-R868sT2wT.webp)

![whiteboard_in_room.jpg](https://less.works/img/design_&_architecture/xwhiteboard_in_room.JPG.pagespeed.ic.XRwD5kBhO3.webp)

Команда окружена досками в ее комнате; люди могут видеть модели на стенах при программировании и с легкостью проводить
JIT-проектирование.
___

### Многокомандные воркшопы для решения общих вопросов по проектированию

Как работать над проектированием и архитектурой на уровне системы? Как работать над вопросами проектирования кросс-системной
"линейки продуктов"?

![groups_in_ws_2.jpg](https://less.works/img/design_&_architecture/xgroups_in_ws_2.JPG.pagespeed.ic.KFS_UTrKuG.webp)

Чуть большим составом, возможно...

- несколько фиче-команд работают над общим компонентом или фреймворком, поскольку фиче-команды работают над компонентами 
перекрестно и синхронизируются на уровне кода
- одна команда или вся продуктовая группа берет на себя разработку *общей* для всех задачи или инфраструктуры,
которая в конечном итоге будет использоваться другими командами или продуктами
- команды организованы как компонентные (т.е. субоптимально), а не как фиче-команды. Одна функция для конечного клиента
проходит через несколько таких команд
- представители нескольких команд собираются вместе, чтобы изучить и решить вопросы архитектуры и проектирования на уровне
системы

В любом из этих случаев полезно, чтобы команды или представители команд - в рамках одного или нескольких продуктов -
проводили **многокомандные воркшопы по проектированию**. Это не просмотр презентаций в PowerPoint, сидя за столом. Это когда,
люди из разных команд рисуют вместе на стенах. На огромных досках они могут работать все вместе. Или разделившись на
подгруппы и работая на отдельных стенах, могут посещать работу друг друга, чтобы научиться и дать обратную связь. Также
некоторые команды могут послать представителя к другой командной стене во время воркшопа.

Кто участвует в таких событиях? Члены фиче-команд, а также технические лидеры, пишущие код, а не PowerPoint-архитекторы или
архитектурные астронавты.

Как часто? Проводите многокомандный воркшоп по проектированию по вопросам "архитектуры" продукта хотя бы один раз в несколько
итераций.

После многокомандного воркшопа по проектированию участники возвращаются в свои команды. Позже, во время повторяющихся
воркшопов *внутри каждой команды*, вернувшиеся люди, которые присутствовали *общекомандном воркшопе*, делятся решениями,
принятыми в разных командах, и помогают своей команде реализовать эти масштабные архитектурные решения в своих эскизах у себя
на стене, а затем в обучении через парное программирование. Таким образом, происходит трансляция идей и решений о
верхнеуровневой архитектуре с межкомандных воркшопов на внутрикомандные.

Обратите внимание, что на акцент поставлен на культуру постоянного "заражения людей" и постоянного менторинга, а не на
"документирование архитектуры" и передачу архитектурных документов.

Воркшоп по проектированию для нескольких команд - это активность *сообщества практиков (Community Of Practice, CoP)*, в данном
случае для проектного или архитектурного CoP. Итак, кто организует регулярные многокомандные воркшопы по проектированию? Это
может быть *фасилитатор CoP воркшопов*.

Есть еще другая причина проводить многокомандные воркшопы по проектированию, которая описана далее ...

### Технические лидеры ведут инженерные воркшопы

Проблема: отсутствие общих навыков проектирования и специальных знаний (об архитектуре, других компонентах,…). Образование -
это лекарство. В бережливом производстве, главные инженеры также являются учителями, тренируя людей в области машиностроения.
Во время воркшопов по проектированию технические лидеры, менеджеры и программисты-архитекторы помогают или своей собственной
"домашней" команде или другим командам. Они могут провести много часов с одной командой у стен, помогая людям углубить их
навыки, а также создавать и поддерживать архитектурную целостность.

![wall_discussion.jpg](https://less.works/img/design_&_architecture/xwall_discussion.JPG.pagespeed.ic.lJJN8FSzvm.webp)

### Архитекторы и системные инженеры являются постоянными членами фиче-команд

Предыдущие предложения, касающиеся воркшопов по проектированию среди нескольких групп*, могли создать впечатление, что
существует отдельная группа архитекторов или группа по системному проектированию - но это не так. Команды в Scrum являются
кросс-функциональными и выполняют всю работу, необходимую для предоставления клиентских решений, включая архитектуру и
системную инженерию. Таким образом, когда продуктовая группа переходит к гибкой разработке, они распускают отделы с
одиночными функциями (например, группу по архитектуре), а участники присоединяются к обычным командам Scrum-разработчиков,
участвуя в практическом проектировании и, особенно, в наставничестве во время воркшопов по проектированию, в т.ч.
многокомандных, парного программирования и SAD воркшопов.

___
**"Член команды" не означает человека, просто "приписанного" к команде. Т.е. это не тот человек, который получает задачи от
одной или нескольких команд продукта, решает их сам и возвращает "свою" завершенную работу.**
___

### Ставьте под сомнения все архитектурные решения

Представим, вы проводите ранний архитектурный анализ и решаете, что язык программирования должен быть выбран как можно
раньше, предположим C++. Наставляйте всех подвергать сомнению и оспаривать все эти предположения и решения, а также находить
способы применения принципа бережливого мышления "решить как можно позже" или отложить обязательства. Например, сделайте
быстрое прототипирование на Ruby, чтобы сначала узнать немного больше. Мы знаем один продукт, который начинался с C++ в
течение четырех итераций, а затем переключался на Java с относительно небольшими усилиями.

### Не следуйте архитектурным решениям, являющимися неактуальными

Наверняка, у всех разработчиков был такой опыт: "Ну, это довольно неудобно, но я впихиваю новое в уже существующий подход,
потому не считаю ценным усилия, которые могут быть вложены, чтобы что-то поменять». *Эти усилия* делятся на 2 большие
категории: технические усилия и политические усилия, что убедить архитекторов, сидящих в башне из слоновой кости. В
небольших системах культура "следования" по сравнению культурой "подвергай сомнению и улучшай" создает лишь небольшие
проблемы, потому что технический долг не так велик... пока. В больших системах - или системах, которым суждено стать
большими - этот технический долг становится чудовищным якорем, который сковывает всю продуктовую группу… навсегда. *Особенно*
в первые годы, когда крупный и растущий продукт все еще "мал", вы хотите вдохновить людей чаще подвергать сомнению
изначальные архитектурные решения и продвигать идеи с глубокими изменениями (достигнутые с помощью рефакторинга и
непрерывной интеграции) до того, как якорь лодки начнет тащить ваш продукт под воду.

### Избегайте архитектурных астронавтов  (PowerPoint-архитекторов)

В небольших организациях мало денег и времени для "архитектурных астронавтов", "PowerPoint-архитекторов" или архитекторов
из башни из слоновой кости, которые описывают системы на абстрактных уровнях, но не могут их реализовать в коде и не имеют
отношения к реальности это самого кода. В больших продуктовых группах такая роль часто появляется. [В книге, которая получила
премию Jolt Productivity Award 2005](http://www.amazon.com/Joel-Software-Occasionally-Developers-Designers/dp/1590593898)
(за вклад в разработку программного обеспечения), автор пишет:

> Это люди, которых я называю Архитектурными Астронавтами. Их очень трудно заставить писать код или разрабатывать программы,
> потому что они не могут перестать думать об архитектуре... Они склонны работать на действительно большие компании, которые
> могут позволить себе иметь множество непродуктивных людей с учеными степенями, которые не добавляют ценности в конечный
> продукт. 

В бережливом мышлении акцент делается на менеджерах-учителях, которые являются мастерами своего дела и наставниками других,
а также на работе в качестве практического инженера в течение многих лет. Разработка крупной продукции в соответствии с
бережливой практикой поощряет главного инженера с современной "высокой технической компетенцией", а также видением бизнеса.
Архитекторы, которые смотрят свысока на "только кодирование" как на нечто, что они уже изучили когда-то, не имеют места в
бережливой или гибкой организации.

Как обсуждалось в совете "Выращивание, а не строительство", некоторые дисфункции возникают из-за убеждения, что код не
является реальной архитектурой, и что технические лидеры не должны соприкасаться с его реальностью.

Кроме того, постоянно развивающиеся *способы и инструменты проектирования ПО* (разработка через тестирование (TDD),
рефакторинг и т.д.) должны влиять на мышление технического руководства. Например, для реального понимания тонкости и влияния
TDD или рефакторинга требуется длительная практика "своими руками". Без этого понимания "архитектор" не знает об
определенных течениях, динамике или инструментах в разработке систем.

Вам нужны эксперты-программисты-архитекторы, которые знакомы с кодом и являются активными разработчиками и наставниками,
обучающими через парное программированию и воркшопы по проектированию.

Этот совет не означает, что технические лидеры только сидят и программируют. Естественно, они принимают архитектурные
решения и сообщают о важных из них (например, на воркшопах по проектированию с участием нескольких команд) и поддерживают
связь с рынком [Hohmann03](http://www.amazon.com/Beyond-Software-Architecture-Sustaining-Solutions/dp/0201775948).

Как вы видите на диаграмме причинно-следственных связей выше (CLD, раздел "Размышления о проектировании") много терминов,
связанных с метафорой "архитектура". "PowerPoint-архитектор" часто физически и социально не связан с реальной работой и
реальными разработчиками, что несовместимо с бережливым принципом "Go See".

### Как можно раньше приступите к разработке "ходячего скелета" с кодом трассировки

Старый и мудрый совет состоит в том, чтобы разработать *ходячий скелет системы*, не важно большой или маленький как можно
раньше. Это поможет получить знания о соответствующей архитектуре, запрограммировав и протестировав вертикальные и
горизонтальные (и любые другие направления) срезы системы
[[Cockburn04](http://www.amazon.com/Crystal-Clear-Human-Powered-Methodology-Small/dp/0201699478)],
[[Monson-Haefel09](http://www.amazon.com/Things-Every-Software-Architect-Should-ebook/dp/B0026OR30S/ref=sr_1_3?ie=UTF8&qid=1415410225&sr=8-3&keywords=Monson+Haefel)].
Это не разработка компонентов или слоев отдельно, скорее это межкомпонентная, межуровневая "вертикальная" разработка,
которая развивает подходящий скелет в *коде*. И при этом это не прототипирование; это разработка продуктивного кода, в котором
реализуется архитектурный фундамент. Создание представляет собой учебный процесс, который может включать короткие циклы
архитектурного анализа, воркшопы по проектированию и моделированию, программирование и рефакторинг
архитекторами-программистами. Этот совет связан со многими последующими советами.

"Программная" часть этого совета, по сути то,
что [Хант и Томас](http://www.amazon.com/Pragmatic-Programmer-Journeyman-Master/dp/020161622X)
назвали *разработкой кода трассировки*.

### Создавайте "вертикальные" архитектурные фрагменты в рамках клиентоориентированных элементов Бэклога

Я (Крейг Ларман) помню, что в 1995 году в ObjectSpace мы разрабатывали продукт для одной компании. Они хотели
получать отчетность и управлять своими бизнес-консультантами и их навыками. По "византийским причинам", выходящим за рамки
этой истории, нам пришлось написать собственную подсистему объектно-реляционного отображения (ORM) на C ++. Таким образом,
для первых трех итераций (если я помню, по три недели каждая) "талантливые" разработчики разработали компонент ORM,
сосредоточив внимание на создании только этой подсистемы. Изящные прокси с *отложенной инициализацией* и *умными шаблонными
указателями*, а также с другими через чур инженерными особенностями. Затем представители клиента посетили демонстрацию
прогресса. Команда была гордой.

Но клиенты были недовольны.

Они понятия не имели, в чем смысл нашего "изобретения", и им казалось, что мы потратили девять недель, не делая
ничего, что им было нужно. Они просто хотели *получать отчетность*  и *управлять своими бизнес-консультантами*. Они хотели
выдернуть отказать от подряда.

Мораль этой истории, которую мы усвоили с трудом, - это классика гибкой разработки: *Устанавливайте цели итераций* на
*ориентированных на клиента функциях или возможностях*, а не на *компонентах или подсистемах*. Тем не менее, как будет видно
из следующего совета, это важная подготовка при проектировании.

В Scrum это означает создание элемента Бэклога Продукта в течение итерации полностью. В контексте XP это было названо
*разработкой пользовательской истории*. В RUP это называется *разработкой на основе сценариев использования*.

Хотя в программном обеспечении нет как таковых "вертикалей", но учитывая то, как обычно изображаются структурные диаграммы
программного обеспечения, можно сказать, что "вертикально" - это когда реализовано сквозь слои и компоненты (пользовательский
интерфейс, база данных и т. д.). Для реализации истории или сценария одного пользователя, развивайте и внедряйте необходимую
архитектуру для поддержки этого сценария, чтобы получить обратную связь. Вместо того, чтобы полностью разрабатывать
"горизонтальные" подсистемы, отделенные от пользовательских функций, разрабатывайте вертикально по уровням и компонентам для
выполнения этой функции, замедляя горизонтальное построение компонентов по мере того, как рассматриваются более 
ориентированные на клиента функции.

Эти "вертикальные" функции клиента разрабатываются фиче-командами по Scrum.

Выше описанный подход можно назвать *инкрементальной разработкой*. Итерация за итерацией создаются новые архитектурные
*вертикальные срезы*, а не *горизонтальные, внутри одного слоя*, через *разработку важных для архитектуры клиентских
функций*.

![arch_slices.png](https://less.works/img/design_&_architecture/xarch_slices.png.pagespeed.ic.yqwmO9-Yoo.webp)

> Постепенно добавляйте архитектурно значимые ориентированные на клиента функции на каждой итерации, которые проходят через
> слои или компоненты
___

Последнее утверждение - разработка, основанная на архитектурно значимых клиентоориентированных функциях - обсуждается в
следующем совете…

### В первую очередь берите в разработку ценные для пользователей задачи с наибольшем влиянием на архитектуру

Этот совет похож на некоторые из предыдущих, но с более сильным акцентом на *сортировке Бэклога, основанной на
риске*.

Несколько лет назад мы тренировали небольшую группу из 100 человек в Берлине. Одна из пользовательских историй от поддержки
требовала масштабирования системы для обработки 80 одновременных сеансов с низким уровнем задержек. Делайте такие истории,
как можно раньше.

В модели ["Инвариантной спиральной разработки"](http://www.sei.cmu.edu/reports/00sr008.pdf) Барри Бёма, являющейся хорошей
архитектурной практикой в масштабируемой разработке, пятый инвариант подразумевает, что ранние итерации фокусируются на
архитектурном этапе в рамках жизненного цикла продукта. К этому этапу основные элементы архитектуры (как аппаратные, так и
программные) должны быть разработаны и проверены путем ранней интеграции и серьезного тестирования производственного кода,
а не путем предположений или простого прототипирования (хотя прототипирование может дополнять основное тестирование). Это
очень разумный совет.

Поэтому в ранних итерациях выбирайте элементы Бэклога, нацеленные на достижение клиентоориентированных целей
(пользовательских историй, сценариев использования, возможностей и т. Д. ...), и одновременно те элементы, которые также
имеют важные архитектурные последствия (например, функции с требованиями производительности или те, которые влияют многие
компоненты). Выберите клиентоцентричные функции, которые благодаря внедрению заставят людей обнаружить и решать основные
архитектурные проблемы на ранних этапах. Не все элементы вынуждают людей определять и решать их на всех основных
уровнях, во всех компонентах, или затрагивать вопросы интеграции или производительности. Избегайте такие элементах в ранних
итерациях, выбирая более сложные с точки зрения работы с рисками.

Этот совет является **примером разработки через управление рисками** (тема спиральных инвариантов), в данном случае
рассматриваются два риска:
- бизнес-риск - не соответствовать тому, что важно для клиента
- технический риск - не построить целостную архитектуру
Оба должны быть рассмотрены на ранних итерациях. Ложной дихотомии тут нет.

### Архитекторы проясняют дальнейший путь развития путем разработки "спайков"

В гигантском продукте, содержащем 20 [MLOC](DICTIONARY.md#MLOC),  "архитекторам" приятно думать следующим образом: "Ну, это
довольно большая и требующая рефакторинга система сейчас, и прошло уже 23 недели с тех пор, как я программировал
последний раз. Мне намного проще написать документ, объясняющий, что я хочу изменить в архитектуре. Почему бы нет? Я знаю,
что происходит". Избегайте этого искушения; Покиньте свою зону комфорта. Поощряйте архитекторов, пишущих код, в первую очередь
совершенствовать и находить идеи, *разрабатывая "спайки"* - один из вариантов исследовательского программирования, которое
"пронзает" все компоненты приложения и позволяет понять жизнеспособность самой идеи
[[Beck99](http://www.amazon.com/Extreme-Programming-Explained-Embrace-Change/dp/0201616416)]. Используйте воркшопы по
проектированию и моделированию или воркшопы по документированию системной архитектуры, чтобы передать знания другим
разработчикам.

### Не позволяйте архитекторам просто "передавать" требования конечным разработчикам

При разработке крупных продуктов такая передача является обычной проблемой. Вместо этого перейдите к модели
архитекторов-программистов, архитекторов, как наставников по парному программированию, архитекторов, как тренеров на
воркшопах по проектированию и т.д.

### "Тигровая команда" делится после победы

Для запуска нового или серьезной переработки архитектуры существующего продукта попробуйте начать с "тигровой
командой", состоящей из экспертных архитекторов-программистов, работающих в одной комнате команды. Не начинайте с гигантской
группы. Держите это "тигровую команду" маленькой, пока это возможно; они сначала пишут код, что "побеждает" ключевые
архитектурные препятствия.

Повторяя цитату (со страницы 1) о крупном разработке SAGE в 1950-х годах, старшего менеджера проекта спросили об извлеченных
уроках:

> Затем его спросили: "Если бы у вас было все снова и снова, что бы вы сделали по-другому?" Он ответил: "Найдите десять
> лучших людей и напишите все сами". 
> [[Horowitz74](http://www.amazon.com/Practical-Strategies-Developing-Software-Systems/dp/0201029774)]

Затем, если потребуется увеличить скорость и нанять больше людей, придумайте, как "тигровая команда" может разделиться, чтобы стать
основой в формировании нескольких новый команд.

Возможно, половина членов тигровой команды разойдутся, чтобы присоединиться к новым фиче-командам. Например, это может быть
возвращение домой в Бангалор после четырех месяцев в Бостоне. Может быть, четыре или пять новых людей присоединятся к
теперь уже уменьшившейся первоначальной команде.

"Бродящие" тигры будут техническими лидерами и обучать членов своих новых команд основным идеям, посредством парного
программирования и во время воркшопов по проектированию.

![start_with_tiger_team.png](https://less.works/img/design_&_architecture/xstart_with_tiger_team.png.pagespeed.ic.VLHlAsTYxS.webp)

> Начните разработку с одной команды "тигров"
___

[Эльссамадиси и Эльшами](http://www.amazon.com/Agile-Adoption-Patterns-Roadmap-Organizational/dp/0321514521) назвали эту
практику "Делись после победы".

Мы помним ужасную историю продуктовой группы, которая не последовала этому совету (мы начали их консультировать только во
время 3-го релиза): их первый релиз был катастрофой. Что произошло? Это был новый продукт, реализованный на C++. Они взяли
Powerpoint-архитекторов из другого успешного продукта, основанного на устаревших технологиях. Эти "опытные эксперты",
которые никогда не использовали C++ или ООП, приступили к написанию архитектурных документов. Затем 200 программистов,
распределенных в двух разных офисах, начали разработку в один день. Многие никогда не работали с ОО языком программирования,
поэтому им дали возможность пройти трехдневный курс по С++. Продукт опоздал на два года, и во время 3-го релиза они все еще
решали основные проблемы с качеством и переделывали "архитектуру".

### SAD-воркшопы в конце "фазы тигра"

Воркшоп по документированию системной архитектуры (system architecture documentation, SAD) может быть полезен в конце "фазы
тигра", чтобы обеспечить передачу знаний новым командам, которые вскоре будут созданы (см. То время, когда стоит провести
SAD). Иногда может быть полезно запускать команды со второго воркшопа по SAD. Обратите внимание, что все эти методы пытаются
снизить потери на передаче информации. Прочтите последующие эксперименты, чтобы узнать больше о **воркшопах по SAD** и
создании **адаптивной документации по системной архитектуре**.

![tiger_team_SAD_workshop.png](https://less.works/img/design_&_architecture/xtiger_team_SAD_workshop.png.pagespeed.ic.sWKLXryuMQ.webp)

> То время, когда стоит провести SAD
___

### Помогите "заразить людей" с помощью SAD-воркшопов

Потери, связанные с передачей знаний через документы, остаются неизменными в разработке программного обеспечения - такая
передача просто не работает, как нужно. Действительно, архитектурные документы редко даже читаются конечными разработчиками.
Таким образом, тема трех советов заключалась в том, чтобы сосредоточиться на обучении разработчиков посредством их
"заражения", посредством тщательного и постоянного личного общения с экспертами-учителями, которые обладают современными
инженерными технологиями, а также с другими техническими лидерами. Благодаря постоянному, в каждой итерации, участию в
воркшопах по *документированию системной архитектуры (SAD)*, парному программированию и
ревью кода эти технические лидеры и эксперты-учителя "заражают" своих коллег все более широкими и глубокими знаниями
архитектуры системы.

![sad_workshop.jpg](https://less.works/img/design_&_architecture/xsad_workshop.jpg.pagespeed.ic.MUjAM-HnIk.webp)

> Воркшоп по SAD, зарисовка нескольких архитектурных схем. Обратите внимание на количество "белых досок".
___

Иногда, этот совет может быть интерпретирован в ложную дихотомию: или воркшопы, или документы. Используйте оба подхода
особенно в крупных системах. Подчеркните, что эксперты - это учителя, и в то же время подкрепите это на SAD. Кроме того,
разрабатывая документацию по системной архитектуре на **SAD-воркшопах** с участием группы среднего размера, часто с
представителями многих команд, само мероприятие становится еще одной возможностью для преподавания и обучения.

Воркшопы по SAD отличается от воркшопов по проектированию. Чем?

- Воркшопы по проектированию проводятся *перед* тем, как приступить к настоящему проектированию - написанию кода. Результатом
воркшопа являются разговоры, обучение и размышления - зарисовки на стенах. Для крупных системных изменений применяются
воркшопы по *проектированию для нескольких групп*. Не важно, для одного компоненты или всей системы, проводятся такие события,
они всегда наполнены творчеством.
- Воркшопы по SAD, наоборот, проводятся *после* реализации функционала (например, вскоре *после* выпуска каждые шесть месяцев).
Воркшопы по SAD ретроспективно инспектирует законченную систему и описывает ее. Такое событие в меньшей степени является
творческим, но более информативным, так как участники узнают больше о *существующей* архитектуре и генерируют идеи для
ее улучшения, которые следует рассмотреть на будущих воркшопах по проектированию для нескольких групп.

В качестве материалов для SAD предложите N+1 модель представления и технические заметки; см. главу *Документирование
архитектуры* в [[Larman04a](http://www.amazon.com/Applying-UML-Patterns-Introduction-Object-Oriented/dp/0131489062)].

Для записи SAD сделайте фотографии N+1 рисунков на досках и сохраните их в вики. Кроме того, введите технические заметки на
вики-страницах.

### Эксперты обучают через ревью кода

Ревью кода обычно проводится для выявления дефектов и это делается редко старшими архитекторами продукта (так кажется). Но
это событие можно использовать не только для обнаружения дефектов, но и для обучения, особенно для улучшения навыков
проектирования и сохранения архитектурной целостности. Ключевым принципом бережливого производств "Go See" или "Пойди
посмотреть на реальное место возникновения проблемы и исправь его там". Архитекторы или эксперты, которые пытаются
установить и поддерживать архитектурную целостность только путем создания презентаций или документов, не добьются успеха.
Но архитекторы, которые являются первоклассными программистами и которые регулярно проводят ревью кода (то самое "реальное
место") с разработчиками, имеют возможность обучать других этому мастерству самым действенным способом, а также
придерживаться источника истинной архитектуры - кода. Этот совет фокусируется на экспертных сотрудниках, как на учителях.

### Не ждите согласования ревью кода от экспертов

Что тут не так?

Начнем с того, что это увеличивает время простоя, количество передач и снижает распространение информации. Также упускается
возможность для коучинга и обучения в том случае, если эксперт, получивший новый код для проверки и одобрения, имеет право
принятия финального решения по вопросу проектирования. Чтобы этого избежать, *он должен быть привлечен на воркшопы по
гибкому проектированию с командой **как можно раньше***,  чтобы научить команду качественному проектированию на начальных
этапах проекта. Таким образом, *конечное* качество проектирования системы тоже станет лучше.

Наличие внешнего согласования также инициирует внешний процесс по отношению к команде; она больше не контролируют его и не
может проводить эксперименты по улучшению.

В компании Nokia (где раньше работал Бас) они применяли традиционный процесс проверки и согласования: код был проверен и
утвержден (или нет) после того, как он был написан. Как и в случае с потерями при передаче, были задержки при рассмотрении,
и обратная связь была неявной. Плюс, если исправления были необходимы, циклы повторялись.

Чтобы это улучшить, они представили технику под названием RaPiD7 [[Kylmäkoski03]](http://dl.acm.org/citation.cfm?id=776847).
Документ был написан и утвержден в ходе одного воркшопа с участием *всех соответствующих заинтересованных сторон*, поэтому
не было необходимости в отдельном цикле проверки / согласования, а также в улучшении уровня знаний.

Этот эксперимент не о прекращении ревью или обратной связи; Речь идет об изменении способов работы таким образом, чтобы
рецензирование добавляло ценности, было быстрым и давало возможность обучиться, а не традиционным процессом отложенного
утверждения и источников потерь.

### Сообщество практиков по проектированию и архитектуре

[Сообщества практиков](https://less.works/less/structure/communities.html) (CoP) являются организационным механизмом для
создания виртуальных групп, создаваемых для решения связанных проблем. Технические лидеры или архитекторы, пишущие код,
которые отвечают за создание и обучение архитектурному видению, являются членами специальных групп. Если эти технические
лидеры разбросаны по разным командам, им необходимо регулярно собираться по многим причинам и иметь общее информационное
пространство. Они могут сформировать сообщество и создать общее wiki-пространство для него.

### Практика "покажи и расскажи" в время воркшопов

Если команды продукта участвуют в общем воркшопе по проектированию, то будет полезным для взаимного обучения командам
посещать "стены" других команд по несколько раз, проводя сеансы "покажи и расскажи". Это также полезно, если одна команда
(например, из семи человек) решает разделиться на две подгруппы во время воркшопа и параллельно моделировать различные
функции. Группу-1 подходит к стене Группы-2, чтобы увидеть и изучить идеи проектирования и помочь их развить. И наоборот.

### Менторы компонентов для поддержания архитектурной целостности при коллективном владении кодом

Успешный переход от единоличного к коллективному владению кодом, поддерживаемый гибкими практиками, не происходит в
одночасье. Практика **компонентных менторов** может помочь. У "особых" компонентов (для которых существует
проблема<sup>8</sup>) есть его наставник, чья роль состоит в том, чтобы обучать других людей, и гарантирует, что изменения,
производимые в нем, являются грамотными, и помогают снизить риск что-либо сломать. Он/она *не являются владельцем
компонента*, изменения вносятся всеми членами фиче-команды. Новичок (или команда новичков) в компоненте просит наставника
компонента научить его и помочь внести изменения, вероятно, на воркшопах по проектированию и/или посредством парного
программирования. Наставник также может проверять все изменения с помощью инструмента "diff", который автоматически
отправляет ему электронное письмо с изменениями. Эта роль отчасти похожа на роль **коммиттера** в разработке с открытым
исходным кодом, но с ключевым отличием - без запрета коммитов других участников; запрет может создать узкие места и задержку
в процессе<sup>9</sup>. Они являются учителями и разработчиками компонентов, а не *"вратами"*. Компонентный наставник - еще
один пример бережливой практики регулярного наставничества со стороны экспертов и повышения общего уровня знаний.

### Списки рассылок компонентов

Другой способ поддержки коллективного владения кодом - это список рассылок (или другой канал коммуникации) для каждого
"особого" компонента. Люди, часто работающие над компонентом, могут обсудить рефакторинг, структуру, ошибки, произвести
ревью кода, объявить об обучении и так далее. Конечно, любой может присоединиться или покинуть список в соответствии с
потребностями, но наставники компонентов являются долгосрочными членами данных рассылок.

### Практики менторинга и internal open source

Гибкая разработка вдохновляет на коллективное владение кодом. Фиче-команды подразумевают работу над *всем необходимым* кодом
в рамках задачи. В этом смысле гибкая разработка похожа на модель internal open source, но с разницей в еще большем
коллективном владении кодом и отсутствием "ворот" коммиттера, которые создают потери. Если необходимо, наставники
компонентов помогают с решением сложных задач, не замыкая на себе процесс. Для тренеров по гибкой разработке internal open
source и практики менторинга могут быть способом объяснить идею коллективного владения кодом, потому что большинство людей
знают, что различные модели работы с открытым исходным кодом могут быть полезными.

Распространите эту практику и на внутренние, а не только на общие компоненты. Вместо того, чтобы "команда в Польше
поддерживает наш инструмент тестирования", поэкспериментируйте с внутренним (или даже общедоступным) общим кодом или
моделью с открытым исходным кодом. Хорошие разработчики осваивают и развивают свои инструменты; эта модель способствует
этому.

### Закладывайте возможность конфигурации при проектировании

Некоторые из наших клиентов выкопали под собой довольно глубокую яму, создав отдельные ветки для настройки своего
продукта для разных клиентов. Те, кто испытал это - особенно в очень больших системах - слишком хорошо знают, что это все
становится "болью" в конфигурации, обслуживании и тестировании по мере того, развивается продукт и количество веток, которые
требуется поддерживать.

Вместо веток закладывайте возможность конфигурации (например, с использованием метаданных или плагинов), которая позволит
активировать/включать (или не включать) определенные компоненты или функции.

### Используйте архитектурные шаблоны и шаблоны проектирования

Детальный архитектурный дизайн для больших систем выходит за рамки текущей области, которая подчеркивает ориентированные на
советы по проектированию, ориентированные на процесс. Но существует множество надежных решений в рамках сообщества развития
**шаблонов проектирования**, помогающих создать гибкую архитектуру. Читайте книги из нашего списка и пробуйте подходы,
описанные в них - [Полезные ссылки](#Полезные-ссылки).

Как класс, шаблоны защищают от изменений в архитектуре **в некоторой точке** посредством косвенного обращения, метаданных,
интерфейсов и полиморфизма и многого другого. Эти методы уменьшают зависимости и позволяют проводить более быструю
параллельную разработку в больших продуктах, которые развивают несколько команд. Создание бОльшего объема знаний и поставка
ценности быстрее являются ключевыми целями бережливое мышления.

Девятый принцип Agile-манифеста уделяет внимание хорошему проектированию: *Постоянное внимание к техническому совершенству и
качеству проектирования повышает гибкость проекта.*

### Развивайте общий словарь терминов

Если технические лидеры постоянно развивают и используют в разговоре известные термины и шаблоны, то это помогает улучшить
общее понимание проекта и, возможно, повысить архитектурную целостность. Частично это происходит благодаря созданию общего
словаря среди разработчиков. Шаблоны имеют официальные опубликованные имена, такие как Layers, MVC, MVP, Strategy, Broker,
Service Locator и т. Д. Эти собственные имена могут использоваться в документации, речи и коде, например, в имени интерфейса
RoutingStrategy. Хотя основная ценность шаблонов заключается в переиспользовании хороших дизайнерских идей, они также могут
создать общий словарь для вашей системы. Это может помочь при масштабировании разработки на 300 человек, находящихся в
разных офисах компании.

## Инженерные рекомендации

За то время, что мы работали с крупными продуктами, обычно это были встраиваемые системы (embedded systems), мы составили
список общих рекомендаций, которые могли бы уменьшить часть боли и страданий, которые на наших глазах испытывают наши
клиенты. В этом разделе перечислены некоторые из этих советов. Но на самом деле эта тема заслуживает отдельной книги ...

### Представьте ваш исходный код в виде HTML-страниц и гиперссылок между ними

В небольшом проекте можно быстро перемещаться по всему исходному коду, просто открытому в вашей среде разработки. Когда, к
примеру, имеется 36 839 файлов и 15 [MLOC](DICTIONARY.md#MLOC), навигация уже не простая. Используйте бесплатный
инструменты, такие как Doxygen ([www.doxygen.org](http://www.doxygen.org)), чтобы преобразовать ваш исходный код в набор
HTML-страниц, в которых все элементы исходного кода (классы, методы, ...) являются гиперссылками. Doxygen (и аналогичные
инструменты) также будут генерировать диаграммы, отражающие более крупные структуры и группы в вашей кодовой базе.
Регенерируйте страницы ежедневно. Это очень полезно для понимания и развития огромной кодовой базы.

### Используйте заглушки и внедрение зависимостей (dependency injections)

Создавайте **заглушки**<sup>10</sup> - или "поддельные" альтернативы кода для многих вещей: классов, интерфейсов с другими
компонентами, аппаратного обеспечения и так далее. Заглушки обычно создаются с помощью реализации альтернативного интерфейса
или путем создания подкласса "реального" класса в объектно-ориентированных проектах, или с помощью указателей функций или
альтернативных файлов реализации по изменяющемуся пути ссылки в проектах на основе C
[[Feathers04]](http://www.amazon.com/Working-Effectively-Legacy-Michael-Feathers/dp/0131177052), например:

```java
interface PrinterMotor {
    void start();
    …
}

class CanonPrinterMotor implements PrinterMotor {
    …
}

class PrinterMotorStub implements PrinterMotor {
    …
}
```

Если нет интерфейса (и даже если он есть), заглушки могут быть созданы с помощью подклассов и переопределения
соответствующих методов:

```java
class CanonPrinterMotor {
    …
}

class PrinterMotorStub extends CanonPrinterMotor {
    …
}
```

Кроме того, обеспечьте "черный ход" во многих классах, который позволяет легко внедрить альтернативную
заглушку, как зависимость, а не в реальный объект; например, с инжекции в конструктор
[[Fowler04]](http://martinfowler.com/articles/injection.html).

```java
class LaserPrinter {

private PrinterMotor motor = new CanonPrinterMotor(); // default …

    public Printer (PrinterMotor alternativeMotor) {
        motor = alternativeMotor;
    }
}
```

Сочетание множества заглушек с множеством "черных ходов" для внедрения зависимостей открывает огромные преимущества:
усиление параллельной разработки, ранняя интеграция с заглушками, когда реальные компоненты недоступны, тестирование
с заглушками, заглушки, которые предоставляют быстрые и хорошо известные демонстрационные данные. В контексте разработки
крупных продуктов массовое использование заглушек - это ключевой метод для параллельной работы и ускорения работы, что
сокращает затраты на ожидание.

### Не используйте заглушки, чтобы отложить интеграцию

Чудесно! Теперь у каждого есть заглушки и у вас есть возможность отложить интеграцию всего кода на месяцы или годы. Даже не
думайте об этом.

### Практикуйте разработку через тестирование / Test-driven development для лучшей архитектуры

[TDD](tdd.md) может улучшить архитектуру системы. Как?

Когда мы занимаетесь коучингом, частым запросом наших клиентов является просьбы помочь с "негибкой архитектурой". Это чаще
всего сводится к проблемам в сильной связанности компонентов - распространенная проблема в унаследованном (legacy) коде,
написанном без использования TDD, потому что первоначальный автор не пытался тестировать компоненты независимо.

С другой стороны, когда разработчик создает новый компонент (например, класс) с TDD или проводит рефакторинг устаревшего,
то нужно разорвать зависимости и нарушить связи этого компонента, чтобы он мог быть протестирован изолированно.
Это требует проектирования (или рефакторинга) для внедрения зависимостей и более широкого использования механизмов для
обеспечения гибкости: интерфейсов, полиморфизма, шаблонов проектирования, структур внедрения зависимостей, указателей
функций и многого другого.

В таком случае TDD поощряет слабое связывание, простоту, гибкость конфигурацию - качества хорошей архитектуры.

### Абстрагируйтесь от уровня ресурсов конкретной Операционной Системы

Мы работаем с двумя клиентами над похожими продуктами - крупными встраиваемыми системами. Клиент А создал собственную
операционную систему (OS) и заложился в своих приложениях на специфику данной ОС. Клиент B создал уровень абстракции ОС
поверх своей оригинальной ОС (VxWorks) - уровень косвенности для снижения связанности в этой точке. В какой-то момент оба
клиента решили перейти на операционную систему Linux реального времени. Клиент B закончил порт через пару месяцев;
Через несколько лет Клиент А все еще проводит исследования на предмет возможности перехода. **Гибкость достигается благодаря
низкой связанности уровней**.

Этот совет автоматически выполняется, если вы используете виртуальную машину (например, Java или аналогичную платформу).
Однако большинство наших клиентов при разработке встраиваемых продуктов используют C/C++ стек. В этом случае попробуйте один
из существующих уровней абстракции ОС с открытым исходным кодом, например Boost или Apache Runtime Library.

#### Введение в интерфейсы и советы по взаимодействию

Определение и развитие интерфейсов между компонентами и межкомпонентное взаимодействие являются основными проблемами при
разработке больших систем. Фактически, это то, что Грэди Буч<sup>11</sup> назвал "пограничным проектированием"
[[Booch96]](http://www.amazon.com/Object-Solutions-Managing-Object-Oriented-Project/dp/0805305947), часто является
доминирующей архитектурной проблемой в крупных приложениях. Также обратите внимание, что "боли интеграции" в многосайтовых
или сверхбольших продуктах является отражением взаимодействия команд, их разрабатывающих. Когда вы работаете с монстром
из 15 [MLOC](DICTIONARY.md#MLOC), состоящим из 234 основных компонентов, каждый из которых содержит в среднем 64
[KLOC](DICTIONARY.md#KLOC), именно вопросы взаимодействия и интерфейсов, как правило, преобладают в повседневных
архитектурных задачах, а не в дизайне какого-либо одного модуля или даже наличие/отсутствия какого-либо модуля.

**Интерфейсы / Interfaces** – в этом разделе под терминов "интерфейсы" мы имеем ввиду следующее:

- Интерфейсы в языках программирования, например в Java или C# (локальные или внешние);
- Сигнатуры операций (имя функции и ее параметры);
- Интерфейсы Web-сервисов (например, WSDL);
- и тому подобное.

Большие системы обычно имеют большой возраст; много кода на C для таких систем это нормально, и "интерфейс" для другого
компонента может быть просто сигнатурой функции, такой как `debet (int, float)`. Другой контекст этих советов состоит в том,
что в группе из 250 человек программист, использующий опубликованный API, может отличаться от программиста, который создавал
его реализацию его много лет назад.

### Избегайте подробного проектирования на старте

Старая и бесполезная стратегия для решения проблемы интерфейсов звучала, как "Перед программированием определите и
зафиксируйте интерфейсы между основными компонентами. Затем используйте процесс управления изменениями, когда интерфейсы
будут меняться". Это модель проектирования, ориентированная на раннее проектирование, вызывает следующие проблемы:

- отложенная реализация - из-за сложности и множества вовлеченных людей
- отсутствие обратной связи на основе использования
- неправильные интерфейсы (из-за отсутствия реалистичной обратной связи)
- медленный процесс изменений
- дополнительный код преобразования или адаптации на обеих сторонах интерфейса, чтобы справиться с неизбежной эволюцией,
когда контракт интерфейса зафиксирован.

Далее рассмотрим рабочие альтернативы данном подходу. Следующие рекомендации предлагают концепции "реши-как-можно-позже",
основанные на Бережливом Мышлении.

### Упрощайте координацию процессом изменения интерфейсов путем создания фиче-команд

[Фиче-команда](https://less.works/less/structure/feature-teams.html) является межкомпонентной и изменяет весь код во всех
компонентах, необходимых для выполнения, ориентированной на клиента функции. Это уменьшает проблемы координации, связанные с
интерфейсами, потому что один и тот же человек или команда работают, как над вызывающей, так и над вызываемой стороне
интерфейса. Напротив, выделенные команды компонентов увеличивают сложность координации процесса изменения интерфейса.

### Избегайте "замороженных" интерфейсов

Есть моменты, когда публичный API действительно необходимо заморозить. Но оспаривайте эти решения, держите как можно больше
артефактов доступными для изменения и экспериментируйте с методами поддержки эволюции интерфейсов. Некоторые методы
будут предложены здесь, а другие - в разделе [Полезные ссылки](#Полезные-ссылки).

### Оборачивайте вызовы внешних компонентов с помощью Proxy или Adapter

*Внешние* компоненты, вызов которых происходит через JMI, RPC, SOAP, промежуточное ПО, ориентированное на сообщения (MOM)
или сокеты, являются *гарантированными* точками, в которых могут быть внедрены заглушки для возможности изолированного
тестирования без обращения к реальным экземплярам. Кроме того, часто меняется сам протокол удаленного взаимодействия
(например, переход с RPC на MOM).

Следовательно, вам должны защититься в этих **точках изменения архитектура**, всегда оборачивая вызовы во внешние компоненты,
используя полиморфизм, шаблоны проектирования Proxy или Adapter
[[GHJV94]](http://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612).

### Начинайте с использования интерфейсов во взаимодействии основных компонентов, потом удалите их, если потребуется

Большие системы обычно состоят из сотен основных компонентов, и они могут быть как внутренними, так удаленными друг от друга.
Мы видим общие проблемы, связанные с взаимодействием между основными компонентами (такими как подсистемы) в больших системах:

- зависимость от знаний того, какой основной компонент является получателем сообщения или вызова операции
- зависимость от знаний протоколов взаимодействия, таких, как прямой вызов функции, RPC, SOAP через HTTP и т. д.
- обработка сложных и повторяющихся ошибок сети
- невозможность использования подключаемых модулей / компонентов из-за проблем, связанных с их сильной связанностью

Следующий совет может помочь ...

Профессор информатики Дэвид Уилер (David Wheeler), как известно, говорил: "Все проблемы в информатике могут быть решены с
помощью другого уровня косвенности".

Решение вышеуказанных проблем заключается в использовании косвенного механизма связи между основными крупными компонентами
(такими как подсистемы), в отличие от чего-то прямого, такого как вызов Java RMI или SOAP. Это "косвенное взаимодействие"
глубже, чем просто добавление адаптера или прокси между компонентами; это означает использование какой-либо формы косвенной
системы обмена сообщениями.

Существует несколько вариантов косвенного обмена сообщениями между основными крупными компонентами. Одним из надежных
вариантов является промежуточное программное обеспечение, ориентированное на сообщения (MOM), такое как JMS и MSMQ. MOM,
богатый на опции, поддерживающий плагины, заслуживает внимательного изучения. Решения MOM для домашнего использования или
с открытым исходным кодом, более легкие "шины сообщений", являются еще одним вариантом. Выполнение межкомпонентной связи с
MOM обеспечивает степень свободы, которая обеспечивает более низкую связь и архитектуру, позволяющую использовать плагины.
Решения MOM также предлагают встроенные функции отказоустойчивости и восстановления.

Также существует вторая часть цитаты Уилера, которая наименее известна. Приводим цитату полностью

> Все проблемы в информатике могут быть решены с помощью другого уровня косвенности. Но обычно это создает другую проблему.

Иногда, "другая проблема" - это влияние на производительность.

Потенциальным недостатком MOM является снижение производительности. В этом случае, как и в случае со слабо типизированным
интерфейсом, вы можете начать с решения MOM, чтобы обнаружить "линий желаний" в коммуникации модулей, игнорируя при этом
снижение производительности. Затем, по мере стабилизации каналов взаимодействия и обнаружения узких мест с точки зрения
производительности, вы замените медленные взаимодействия MOM более быстрыми механизмами, такими как Java RMI. Это еще один
пример "вытягивающего" проектирования. MOM остается механизмом по умолчанию, если он не является производительным для случая.

Если этот совет сочетать с рекомендацией всегда использовать Proxy или Adapter для связи с внешними
компонентами, то изменение протокола с MOM на RMI на внутренний код никак не влияет - нужно просто добавить
альтернативный адаптер.

## Заключение

Здания жесткие и неподвижные. Программное обеспечение гибкое и динамичное. Таким образом, "архитектура" далека от идеальной
метафоры для создания программного обеспечения; это может даже способствовать неправильному пониманию того, что существует
какое-то проектирование, оторванное от исходного кода, и что оно по существу не меняется.

Но программное обеспечение постоянно развивается и обновляется с каждой модификацией исходного кода каждым программистом.
Ключевой вопрос: станет ли оно красивым и ухоженным садом или джунглями сорняков?

Советы, приведенные здесь, поощряют высококачественное эмерджентное проектирование благодаря культуре развития садоводства и
более коротких и ценных циклов обратной связи, а не "архитектуре". А для этого нужны великие садоводы:
архитекторы-программисты, которые активно создают архитектуру и постоянно обучают других программистов во время
парного программирования и воркшопов по моделированию.

Для устойчивых крупномасштабных гибких систем людям жизненно важно освоить гибкие методы проектирования: шаблоны
проектирования, внедрение зависимостей, разработку через тестирование, рефакторинг и многое другое. Но без коучинга со
стороны технических экспертов во время написания кода эти методы не будут приниматься и распространяться среди разработчиков.

Мы не предлагаем никакой ложной дихотомии между разработкой и проектированием; последнее ценно, особенно в крупных системах.
Помимо сосредоточения внимания на коде, воркшопы по моделированию - это отличная и легкая техника, позволяющая быстро
исследовать сложные конструкции и учиться вместе. Возможно, ключевым ингредиентом являются массивные "белые доски", поэтому
займите ими все стены!

## Полезные ссылки

- Сайт [www.codingthearchitecture.com](http://www.codingthearchitecture.com) подчеркивает необходимость того, чтобы
архитекторы были опытными действующими разработчиками.
- Многие из наших клиентов имеют огромное количество "грязного" унаследованного кода, который сложно протестировать
изолированно и трудно поддерживать. Книга Майкла Физерса
["Working Effectively with Legacy Code"](http://www.amazon.com/Working-Effectively-Legacy-Michael-Feathers/dp/0131177052)
является важным противоядием, описывающим методы, позволяющие разработчикам начать разработку более гибкой архитектуры в
рамках существующей базы кода.
- Ключевым элементом технической гибкости является шаблоны проектирования. Рассмотрим следующие статьи на эту тему:
[Design Patterns](http://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612),
[Pattern-Oriented Software Architecture](http://www.amazon.com/Pattern-Oriented-Software-Architecture-Volume-Patterns/dp/0471958697)
(в 5 томах),
[Applying UML and Patterns](https://www.amazon.com/Applying-UML-Patterns-Introduction-Object-Oriented/dp/0131489062),
and [Pattern Languages of Program Design](https://www.amazon.com/Pattern-Languages-Program-Design-Coplien/dp/0201607344)
(в 5 томах).
- Две книги Боба Мартина вдохновляют на адаптивную архитектуру:
[Agile Development, Principles, Patterns and Practices](http://www.amazon.com/Software-Development-Principles-Patterns-Practices/dp/0135974445)
и
[Clean Code: A Handbook of Agile Craftsmanship](http://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882).
- Еще две полезные книги, ориентированные на качественный код, включают:
[Code Complete](http://www.amazon.com/Code-Complete-Practical-Handbook-Construction/dp/0735619670) Стива Макконнелла и
[Implementation Patterns](http://www.amazon.com/Implementation-Patterns-Kent-Beck/dp/0321413091) Кента Бэка.
- [Growing Object-Oriented Software, Guided by Tests](http://www.amazon.com/Growing-Object-Oriented-Software-Guided-Tests/dp/0321503627)
Стив Фриман и Нат Прайс укрепляют культуру "выращивания", а не определяют "архитектуру".
- [Domain-Driven Design](http://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215) Эрика Эванса
поощряет вдумчивый итеративный дизайн, общее понимание и модель предметной области, которая должна быть хорошо выражена в
коде.
- Статья [Agile Product Development](http://connection.ebscohost.com/c/articles/1378797/agile-product-development-managing-development-flexibility-uncertain-environments)
исследует бизнес-ценность разработки продукта и гибкости дизайна, а также то, как можно измерить гибкость разработки.

## Сноски

1. Нет никакой ложной дихотомии. Этот пример не означает, что нужно избегать технического совершенства или тщательного
проектирования. Он лишь предлагает проектирование и архитектуру, которые прекрасно адаптированы быть более отзывчивыми к
новым знаниями.
2. Это разные вещи. Когда вы создаете материальный объект, такой как аппаратное устройство; мы имеем в виду архитектуру
программного обеспечения.
3. Термин "*архитектура программного обеспечения*" не является "истиной"; название случайно возникло у некоторых
молодых людей, которые искали аналогии. Как и все аналогии (включая "садоводство"), он имеет свои сильные и слабые стороны.
4. Трехмерная (3D) печать, в которой сложные объекты создаются на 3D-принтере, аналогична в этом отношении.
5. Например, [Write-On Cling Sheets](http://www.amazon.com/National-Brand-Write-On-Static/dp/B0000E2RGH)
или [Magic Chart](http://www.amazon.co.uk/Legamaster-1591-00-Magic-Chart-White/dp/B00961KPUE).
6. Примечательно, но мы знаем нескольких людей, которые работали на поставщиков инструментов CASE/MDD/MDA, но сами эти
инструменты при разработки они не использовали. Также следует отметить, что программисты в компаниях-производителях
инструментов CASE/MDD/MDA часто не используют свой собственный инструмент для разработки своего же собственного инструмента!
7. Это может быть полезно для создания проектной документации, но для уменьшения потерь при передаче подходящее
средство для обсуждения и понимания идей, также и во время воркшопа по проектированию - только у "стен".
8. Типичная причина для беспокойства по поводу "особых" компонентов заключается в том, что код не "чистый",
хорошо переработанный и окружен множеством модульных тестов. Решение состоит в том, чтобы его очистить ("остановить и
исправить"), после чего наставник компонента может и не понадобиться.
9. Но роли не идентичны. Опекуны (или "стюарды") проводят больше времени в обучении и программировании в паре,
позволяют коммиты в любое время. Коммиттеры также обучают, но немного меньше, и контролируют коммиты кода.
10. Некоторые неправильно используют термин **mock**, когда подразумевается заглушка или, в более широком смысле,
**тестовый дублер**. Мартин Фаулер говорил об этом в своей статье
["Mocks Aren’t Stubs"](http://martinfowler.com/articles/mocksArentStubs.html). На практике заглушки встречаются гораздо
чаще, чем mocks [Meszaros07](http://www.amazon.com/xUnit-Test-Patterns-Refactoring-Code/dp/0131495054).
11. Программное обеспечение является быстро меняющейся областью; лидеры мысли быстро исчезают за одно поколение. Не
пропустите изучение работ Грэди Буча, пионера OOD.
